This is spro.info, produced by makeinfo version 4.11 from spro.texi.

SPro: Speech Signal Processing Toolkit.

   This file documents the SPro toolkit, release 5.0, for speech signal
analysis.

   Copyright 1996 - 2010, Guillaume Gravier.


File: spro.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Spro
****

   This file documents the SPro toolkit for speech signal processing,
for SPro release 5.0.

* Menu:

* Introduction::                What is SPro?
* Speech analysis::             Basics of speech analysis techniques
* SPro tools::                  The SPro user manual
* SPro library::                The SPro programmer manual
* Reference guide::             Quick reference guide
* Changes::                     Changes in SPro
* Index::                       Index


File: spro.info,  Node: Introduction,  Next: Speech analysis,  Prev: Top,  Up: Top

1 Introduction
**************

* Menu:

* Overview::                    What is SPro good for?
* Content::                     How to read this document?
* Installing::                  SPro installation
* License::                     Distribution license
* Bugs::                        Reporting bugs
* Contributors::                People who contributed


File: spro.info,  Node: Overview,  Next: Content,  Prev: Introduction,  Up: Introduction

1.1 What is SPro?
=================

SPro is a speech signal processing toolkit which provides runtime
commands implementing standard feature extraction algorithms for speech
and speaker recognition applications and a C library to implement new
algorithms and to use SPro files within your own programs.

   SPro was originally designed for variable resolution spectral
analysis but also provides for feature extraction techniques
classically used in speech applications. There are commands for the
following representations:
   * filter-bank energies

   * cepstral coefficients (filter-bank or linear prediction)

   * linear prediction derived representation (prediction and reflection
     coefficients, log area ratios and line spectrum pairs)

Though the toolkit has been designed as a front-end for applications
such as speech or speaker recognition, we believe the library provides
enough possibilities to implement various feature extraction algorithms
easily (e.g. zero crossing rate). However, no command for such features
is provided.

   The library, written in ANSI C, provides functions for the following:
   * waveform signal input

   * low-level signal processing (FFT, LPC analysis, etc.)

   * low-level feature processing (lifter, CMS, variance normalization,
     deltas, etc.)

   * feature I/O
   The library does not provide for high-level feature extraction
functions which directly converts a waveform into features, mainly
because such functions would require a tremendous number of arguments
in order to be versatile. However, it is rather trivial to write such a
function for your particular needs using the SPro library.


File: spro.info,  Node: Content,  Next: Installing,  Prev: Overview,  Up: Introduction

1.2 How to read this manual?
============================

The manual is divided into three main parts:
  1. user manual

  2. programmer manual

  3. reference manual

   *note SPro tools:: is the user manual. It provides a description of
the speech analysis algorithms involved (*note Speech analysis::) and
explains in details the use and the implementation of the SPro commands
`sfbank', `sfbcep', `slpc', `slpcep' and `scopy'. *note File formats::
describes the supported waveform file formats and the SPro feature file
format. The next sections are dedicated to the detailed description of
the SPro tools.

   *note SPro library:: is the programmer manual which describes the
library main data structures and the associated functions.

   *note Reference guide:: provides a quick reference manual for the
SPro tools syntax.

   If you have been using a former version of SPro, read *note
Compatibility:: carefully for crucial information on the
(in)compatibility of SPro 5.0 with the previous versions.

   Finally, to learn more about the evolution of SPro, the history of
the various SPro releases is detailed in *note Changes::.


File: spro.info,  Node: Installing,  Next: License,  Prev: Content,  Up: Introduction

1.3 Installing SPro
===================

Installation follows the standard GNU installation procedure. The two
following lines in your favorite shell
       ./configure
       make
   will build the library and the runtimes. SPro supports some extra
features based on some external packages. These features can be turned
on/off (depending on whether you have them already installed on your
machine) using the `--with-xxx' options of the configure script.
Supported enable options are:
       --with-sphere[=path]     SPHERE 2.6 file format support
   If the SPHERE library is installed in a standard place on your
system (e.g. `/usr/local/include' and `/usr/local/lib'), there is no
need to specify PATH. Otherwise, PATH should point to the directory
where the SPHERE library has been installed. `configure' will search
for the library includes in PATH`/include' and for the archives in
PATH`/lib'.  Compiling SPro with the `-O3' option of the `gcc' compiler
(`CFLAGS=-O3') is a good idea for sake of rapidity.

   Before installing, you may want to check your build by typing
       make check

   Finally, installing the library, the runtimes and the info
documentation can be done running
       make install
   The installation path is specified by the configuration script (try
`./configure --help' for details) and defaults to `/usr/local'.

   See file `INSTALL' in the distribution top directory for more
details.

   To the author knowledge, SPro has been successfully build and used on
Linux, SPARC/SunOS, and HP-UX. It should also work on AIX though this
has not been tested so far.


File: spro.info,  Node: License,  Next: Bugs,  Prev: Installing,  Up: Introduction

1.4 License
===========

As of release 5.0, SPro is distributed as a free software under the MIT
License agreement:

        Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use, copy,
       modify, merge, publish, distribute, sublicense, and/or sell
     copies    of the Software, and to permit persons to whom the
     Software is    furnished to do so, subject to the following
     conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
       BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
     AN    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
     OR IN    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
     IN THE    SOFTWARE.

   Previous releases are distributed under the GNU Public License
agreement.


File: spro.info,  Node: Bugs,  Next: Contributors,  Prev: License,  Up: Introduction

1.5 Reporting bugs
==================

Bugs should be reported to <guig@irisa.fr>. Feel free to submit a
diagnostic or even a patch along with your bug report if you kindly
bothered to do the trouble-shooting. This is always appreciated.


File: spro.info,  Node: Contributors,  Prev: Bugs,  Up: Introduction

1.6 Contributors
================

Along the years, SPro has benefited from the help of several
contributors. Here is a list, in alphabetical order, of those brave
souls who contributed code to the software: Raphae"l Blouet, Pierre
Duhamel, Sacha Krstulovic, Johnny Mariethoz, Sylvain Meigner, Alexey
Ozerov, Jacques Prado and Frederic Wils.


File: spro.info,  Node: Speech analysis,  Next: SPro tools,  Prev: Introduction,  Up: Top

2 Speech analysis techniques
****************************

This section provides a brief scientific overview of the speech signal
analysis techniques involved in SPro with a particular focus on variable
resolution spectral analysis. It also defines the equations and methods
implemented in SPro.

* Menu:

* Short term analysis::         Short term windows and pre-emphasis
* Variable resolution::         Variable resolution spectral analysis
* Filter-banks::                Filter-bank speech analysis
* LPC analysis::                Linear prediction speech analysis
* PLP analysis::                Perceptual linear prediction
* Cepstrum::                    Cepstral analysis
* Deltas and normalization::    Delta, acceleration and feature normalization


File: spro.info,  Node: Short term analysis,  Next: Variable resolution,  Prev: Speech analysis,  Up: Speech analysis

2.1 Pre-emphasis and windowing
==============================

Speech is intrinsically a highly non-stationary signal. Therefore,
speech analysis, whether FFT-based or LPC-based, must be carried out on
short segments across which the speech signal is assumed to be
stationary. Typically, the feature extraction is performed on 20 to 30
ms windows with 10 to 15 ms shift between two consecutive windows.  To
avoid problems due to the truncation of the signal, a weighting window
with the appropriate spectral properties must be applied to the
analyzed chunk of signal. SPro implements three such windows
        HAMMING        w_i = 0.54 - 0.46 \cos(i \pi^2 / N)
        HANNING        w_i = (1 - \cos(i \pi^2 / N)) / 2
        BLACKMAN       w_i = 0.42 - 0.5 \cos(i \pi^2 / N) + 0.08 cos(2 i
                       \pi^2 / N)
   where N is the number of samples in the window and i \in [0,N-1].

   Pre-emphasis is also traditionally use to compensate for the
-6dB/octave spectral slope of the speech signal. This step consists in
filtering the signal with a first-order high-pass filter H(z) = 1 - k
z^-1, with k \in [0,1[. The pre-emphasis filter is applied on the input
signal before windowing.


File: spro.info,  Node: Variable resolution,  Next: Filter-banks,  Prev: Short term analysis,  Up: Speech analysis

2.2 Variable resolution spectral analysis
=========================================

Classical spectral analysis has a constant resolution over the frequency
axis. The idea of variable resolution spectral analysis(1) is to vary
the spectral resolution as a function of the frequency. This is
achieved by applying a bilinear transformation of the frequency axis,
the transformation being controlled by a single parameter a. The
bilinear warping of the frequency axis is defined by          f' = arctan |(1 - a^2) sin f / ((1 + a^2) cos f - 2a) | ,
   where f and f' are the frequencies on the original and transformed
axis respectively and a \in ]-1,1[.  Spectral analysis is done with a
constant resolution on the warped axis f' and therefore with a variable
resolution on the original axis.  Clearly, positive values of a leads
to a higher low frequency resolution while negative values give a
better high frequency resolution. If a equals one, the transformation
is the identity thus resulting in a classical constant resolution
spectral analysis.

   Using variable resolution spectral analysis with a filter-bank is
rather trivial since it simply consists in determining the filter's
central frequency according to the warping. *Note Filter-banks::.

   Linear predictive models with variable resolution spectral analysis
is also possible. Very briefly, the idea consists in solving the normal
equations on the _generalized_ auto-correlation rather than on the
traditional auto-correlation sequence. The generalized auto-correlation
r(p) is the correlation between the original signal filtered by a
corrective filter mu(z) = (1 - a^2) / (1 - a z^-1)^2 and the latter
filtered p times by a correction filter of response                     H(z) = ((1 / z) - a) / (1 - a / z)
   *Note LPC analysis::, for more details.

   ---------- Footnotes ----------

   (1) Variable resolution spectral analysis of a signal is presented
in details in `C. Chouzenoux, Analyse spectrale a` re'solution
variable: application au signal de parole, Ph.D. thesis, ENST Paris,
1982', where it is applied to speech coding.


File: spro.info,  Node: Filter-banks,  Next: LPC analysis,  Prev: Variable resolution,  Up: Speech analysis

2.3 Filter-bank analysis
========================

Filter-bank is a classical spectral analysis technique which consists in
representing the signal spectrum by the log-energies at the output of a
filter-bank, where the filters are overlapping band-pass filters spread
along the frequency axis. This representation gives a rough
approximation of the signal spectral shape while smoothing out the
harmonic structure if any. When using variable resolution analysis, the
central frequencies of the filters are determined so as to be evenly
spread on the warped axis and all filters share the same bandwidth on
the warped axis. This is also applied to MEL frequency warping, a very
popular warping in speech analysis which mimics the spectral resolution
of the human ear. The MEL warping is approximated by mel(f) = 2595
\log_10(1 + f / 700).

   SPro provides an implementation of filter-bank analysis with
triangular filters on the FFT module.  The energy at the output of
channel i is given by                    e_i = \log \sum_j=1^N h_i(j) ||X(j)||
   where N is the FFT length(1) and h_i is the filter's frequency
response as depicted above. The filter's response is a triangle
centered at frequency f_i with bandwidth [f_i-1,f_i+1], assuming the
f_i's are the central frequencies of the filters determined according
to the desired spectral warping.

   ---------- Footnotes ----------

   (1) Actually half of the FFT length.


File: spro.info,  Node: LPC analysis,  Next: PLP analysis,  Prev: Filter-banks,  Up: Speech analysis

2.4 Linear predictive analysis
==============================

Linear prediction is a popular speech coding analysis method which
relies on a source/filter model if the speech production process. The
vocal tract is modeled by an all-pole filter of order p whose response
is given by                   H(z) = 1 / (1 + \sum_i=1^p a_i z^-i) .
   The coefficients a_i are the prediction coefficients, obtained by
minimizing the mean square prediction error. The minimization is
implemented in SPro using the _auto-correlation_ method.

   The idea of the resolution algorithm is to iteratively estimate the
prediction coefficients for each prediction order until the required
order is reached. Assuming the prediction coefficients for order n-1
are known and yields a prediction error e_n-1, the estimation of the
coefficients for order n rely on the n'th reflection coefficients
defined as              k_n = - (1 / e_n-1)\sum_i=0^n-1 a_n-1(i) r(n-i) ,
   where r is the autocorrelation of the signal. Given the reflection
coefficient k_n, the prediction coefficients are obtained using the
recursion                     a_n(i) = a_n-1(i) + k_n a_n-1(n-i)
   for i=1,\ldots,n-1 and a_n(n) = k_n. Finally, the prediction error
for order n is given by                         e_n = e_n-1 ( 1 - k_n^2 ) .
   For variable resolution, the _generalized_ auto-correlation sequence
is used instead of the traditional auto-correlation.  *Note Variable
resolution::. for details on generalized auto-correlation.

   The all-pole filter coefficients can be represented in several
equivalent ways. First, the linear prediction coefficients a_i can be
used directly. The reflection (or partial correlation) coefficients k_i
\in ]-1,1[ used in the resolution algorithm can also be used to
represent the filter. The log-area ratio, defined as                 g_i = 10 \log_10 ((1 + k_i) / (1 - k_i)) ,
   is also a popular way to define the prediction filter. Last, the line
spectrum frequencies (a.k.a. line spectrum pairs) are also frequently
used in speech coding. Line spectrum frequencies is another
representation derived from linear predictive analysis which is very
popular in speech coding.


File: spro.info,  Node: PLP analysis,  Next: Cepstrum,  Prev: LPC analysis,  Up: Speech analysis

2.5 PLP analysis
================

Perceptual Linear Prediction (PLP) is combines filter-bank analysis and
linear prediction to compute linear prediction coefficients on a
perceptual spectrum. The filter-bank power spectrum is filtered using an
equal loudness curve and passed through a compression function   f(x) =
x^1/n where usually n=3, thus resulting in an auditory spectrum from
which the autocorrelation is computed by inverse discrete Fourier
transform. Linear prediction coefficients are then carried out as usual
from the autocorrelation.


File: spro.info,  Node: Cepstrum,  Next: Deltas and normalization,  Prev: PLP analysis,  Up: Speech analysis

2.6 Cepstral analysis
=====================

Probably the most popular features for speech recognition, the cepstral
coefficients can be derived both from the filter-bank and linear
predictive analyses. From the theoretical point of view, the cepstrum is
defined as the inverse Fourier transform of the logarithm of the Fourier
transform module. Therefore, by keeping only the first few cepstral
coefficients and setting the remaining coefficients to zero, it is
possible to smooth the harmonic structure of the spectrum(1). Cepstral
coefficients are therefore very convenient coefficients to represent
the speech spectral envelope.

   In practice, cepstral coefficients can be obtained from the
filter-bank energies e_i via a discrete cosine transform (DCT) given by
           c_i = \sqrt2/N sum_j=1^N e_j \; \cos(\pi i (j-0.5)
/ N) , where N is the number of channels in the filter-bank and i \in
[1,M] (M <= N). Cepstral coefficients can also be obtained from the
linear prediction coefficients a_i according to         c_i = -a_i + (1 / i) \sum_j=1^i-1 (i - j) * a_j  * c_i-j ,
   for i \in [1,M] with M <= P, the prediction order.

   Cepstral coefficients have rather different dynamics, the higher
coefficients showing the smallest variances. It may sometimes be
desirable to have a constant dynamic across coefficients for modeling
purposes. One way to reduce these differences is liftering which
consists in applying a weight to each coefficients. The weight for the
i'th coefficient is defined in a parametric way according to                       h_i = 1 + L \sin(i\pi/L) / 2 ,
   where L is the lifter parameter, typically equals to 2M.

   ---------- Footnotes ----------

   (1) Somehow, zeroing the last cepstral coefficients is like applying
a low-pass filter to the (log module of) the original signal spectrum.


File: spro.info,  Node: Deltas and normalization,  Prev: Cepstrum,  Up: Speech analysis

2.7 Deltas and normalization
============================

Feature normalization can be used to reduce the mismatch between signals
recorded in different conditions. In SPro, normalization consists in
mean removal and eventually variance normalization. Cepstral mean
subtraction (CMS) is probably the most popular compensation technique
for convolutive distortions. In addition, variance normalization
consists in normalizing the feature variance to one and is a rather
popular technique in speaker recognition to deal with noises and channel
mismatch. Normalization can be global or local. In the first case, the
mean and standard deviation are computed globally while in the second
case, they are computed on a window centered around the current time.

   To account for the dynamic nature of speech, it is possible to append
the first and second order derivatives of the chosen features to the
original feature vector. In SPro, the first order derivative of a
feature y_i is approximated using a second order limited development
given by       y_i'(t) = (y_i(t+1) - y_i(t-1) +2 (y_i(t+2) - y_i(t-2))) / 10 .
   Second order differences, known as accelerations, are obtained by
derivating the first order differences. It is therefore not possible to
have the acceleration without the delta features.


File: spro.info,  Node: SPro tools,  Next: SPro library,  Prev: Speech analysis,  Up: Top

3 The SPro tools
****************

* Menu:

* File formats::                Waveform and feature file formats
* Common options::              Tools common options
* I/O via stdin and stdout::    Standard input, standard output and pipes
* Extracting features::         Feature extraction with SPro
* Manipulating features::       The scopy utility for manipulating feature streams


File: spro.info,  Node: File formats,  Next: Common options,  Prev: SPro tools,  Up: SPro tools

3.1 File formats
================

* Menu:

* Waveform file format::        Supported input waveform file formats
* Feature file format::         Output feature file format

   This section describes the file formats manipulated by SPro. Most
SPro tools input signal from a _waveform stream_ and output feature
vectors to a _feature stream_.


File: spro.info,  Node: Waveform file format,  Next: Feature file format,  Prev: File formats,  Up: File formats

3.1.1 Waveform streams
----------------------

Waveform streams are files which contains the signal samples, either in
raw PCM format or in an encoded format to save disk space. Currently,
SPro supports raw, mono, 16bits/sample files, as well as A-law or U-law
compressed 8bits/sample files(1), WAVE files and optionally SPHERE(2)
files.  The SPHERE format is only supported if SPro has been compiled
with the SPHERE library (`--with-sphere' in `configure'). Raw format
(i.e. with no header) with a 8 kHz sample rate is the default assumed
by SPro if not otherwise specified.

   Waveform are considered as streams by SPro and are read via an input
buffer which means they can be of arbitrary (even infinite) length. Even
file formats for which the number of samples is known in advance from
the header will not be entirely loaded into memory. In particular, this
mechanism makes it possible to read waveforms from the standard input
even though the number of signals is not known offhand. One particularly
interesting consequence is the possibility to pipe the output of an
external command into the input of a SPro command. For example, it is
possible using a pipe to support file formats which are not supported by
SPro. The following line
       madplay --left --output=raw:- foo.mp3 | sfbcep -f 11025 - foo.mfcc
   shows how to decode the left channel of an MP3 encoded file
(`foo.mp3') into a raw, mono, 16 bits/sample file which is then piped
into the `sfbcep' tool, assuming the sample rate of the MP3 file is
11,025 Hz.

   ---------- Footnotes ----------

   (1) U-law and A-law formats are used in telephony, or alternately as
the standard audio format in the SUN SOLARIS OS.

   (2) SPHERE is the file format used by most NIST tools and databases.
See `http://www.nist.gov/speech' for the SPHERE package.


File: spro.info,  Node: Feature file format,  Prev: Waveform file format,  Up: File formats

3.1.2 Feature streams
---------------------

A feature streams is a file containing feature vectors. The format used
to store the feature vectors is specific to SPro and consists of a
header followed by data. The header itself is divided in two parts, an
optional variable length header and a fixed length compulsory header.

   To avoid byte-order problems, binary parts of the feature streams,
such as the fixed length header and the feature vectors, are always
stored in little-endian format (Intel-like processor) and therefore
must be swapped if read on a big-endian (Motorola-like processor)
machine. Byte swapping is automatically taken care of when using the
library functions to read SPro streams. *Note SPro library::, for
details on SPro stream I/O functions.

   The variable length header is an optional ASCII header containing
`attribute = value' statements, starting with a `<header>' tag and
ending with `</header>'. The following is a sample variable length
header:
     <header>
     a_field = an arbitrary value;            # a comment

     date = Wed Jul 23 14:59:12 CEST 2003;    # this is the date
     snr = 20 dB;                             # SNR
     </header>
Both the `attribute' and `value' strings are arbitrary. Note that as of
now, none of the SPro tools output variable length headers. However,
such headers are supported and can be added using the `cat' or `bcat'
command. For example, the command
     bcat header.txt foo.mfcc > bar.mfcc
   could be used to add the variable length header contained in file
`header.txt' to the output of an SPro command `foo.prm', the resulting
file being `bar.prm'. The header file `header.txt' is a regular text
file containing text such as given in the example above, where the last
line of the file must consist of the `</header>' tag, possibly with a
carriage return.

   The compulsory fixed length header is a 10 byte binary header
containing the feature vector dimension(1) (`unsigned short' = 2
bytes), a flag describing the content of the feature vector (`long' = 4
bytes) and the frame rate in Hz (`float' = 4 bytes). The feature stream
description flag is actually a field of bits with the following meaning
        *bit*   *letter**description*
        1       `E'     feature vector contains log-energy.
        2       `Z'     mean has been removed
        3       `N'     static log-energy has been suppressed (always
                        with `E' and `D')
        4       `D'     feature vector contains delta coefficients
        5       `A'     feature vector contains delta-delta coefficients
                        (always with `D')
        6       `R'     variance has been normalized (always with `Z')
   The letter in the second column corresponds to the letter used in all
the SPro tools to modify or visualize the feature description flags.

   Feature vectors, or data, are stored after the header in time
ascending order. A feature vector is a binary vector of `float''s as
illustrated in the following example
     +-----------------+---+-----------------+----+-----------------+---+
     |     static      | E |      delta      | dE |    delta delta  |ddE|
     +-----------------+---+-----------------+----+-----------------+---+
with the static coefficient first, optionally followed by the
log-energy, the delta and delta-delta features as indicated by the
feature description flag.

   ---------- Footnotes ----------

   (1) Note that, as opposed to previous versions if SPro, the
dimension in the header correspond to the total feature vector
dimension.


File: spro.info,  Node: Common options,  Next: I/O via stdin and stdout,  Prev: File formats,  Up: SPro tools

3.2 Common options
==================

Here is a list of options common to all (or most of) the tools. The
`scopy' feature manipulation tool options slightly differ from the list
below since most of the options are concerned with waveform processing.

* Menu:

* I/O options::                 Common I/O options
* Framing options::             Common frame blocking options
* Feature vector options::      Common feature vector extraction options
* Miscellaneous options::       More common options


File: spro.info,  Node: I/O options,  Next: Framing options,  Prev: Common options,  Up: Common options

3.2.1 I/O options
-----------------

The following options are used to control the waveform and feature I/Os:
`-F, --format=str'
`'
     Specify the input waveform file format. The format string `str' is
     one of `PCM16', `ALAW', `ULAW', `wave' or `sphere', the latter
     being possible only if SPro was compiled with the SPHERE library.
     Argument is case insensitive. Default value is `PCM16'.

`-f, --sample-rate=f'
`'
     Set input waveform sample rate to `f' Hz for `PCM16', `ALAW' and
     `ULAW' waveform files. This option is ignored for waveform file
     formats for which the sample rate is specified in the header.
     Default value is 8,000 Hz.

`-x, --channel=n'
`'
     For multiple channel waveform files, set the channel to consider
     for feature extraction. Default value is 1.

`-B, --swap'
`'
     Swap the input waveform samples. This is particularly useful for
     waveform files generated on a machine with a different endian.
     Default is not to swap.

`-I, --input-bufsize=n'
`'
     Set the input buffer size to `n' kbytes. The smaller the input
     buffer size, the more disk access and therefore, the slower the
     program is. So you will have to choose between speed and memory!
     Default is 10 Mbytes.

`-O, --output-bufsize=n'
`'
     Set the output buffer size to `n' kbytes. Again, you need a
     compromise between speed and memory requirements. However, one
     important point is that global processing such as mean
     subtraction, energy normalization and delta computation are done
     on the buffer basis (i.e.  such processings are done only when the
     buffer is full or at the end of the stream, whichever comes first)
     which introduces some inconsistencies at the buffer boundaries(1).
     Using a small output buffer size can then result in many boundary
     problems and it is recommended not to diminish the output buffer
     size below a couple of thousand frames. Default is 10 Mbytes.

`-H, --header'
`'
     Output extended (variable length) header in addition to the
     mandatory header.

   ---------- Footnotes ----------

   (1) This is a known 'bug' that should be corrected someday. It is
actually rather impossible to correct the bug for global normalization
which would require to store all of the data into memory. However, it
is possible -- and probably desirable -- to correct things when a
sliding window is specified.


File: spro.info,  Node: Framing options,  Next: Feature vector options,  Prev: I/O options,  Up: Common options

3.2.2 Waveform framing options
------------------------------

Waveform framing is driven by the following options:
`-k, --pre-emphasis=f'
`'
     Set the pre-emphasis coefficient to `f'. Default is 0.95.

`-l --length=f'
`'
     Set the analysis frame length to `f' ms. Default is 20.0 ms.

`-d, --shift=f'
`'
     Set the interval between two consecutive frames to `f' ms. Default
     is 10.0 ms.

`-w, --window=str'
`'
     Specify the waveform weighting window. The window is one of
     `Hamming', `Hanning', `Blackman' or `none'. If the argument is
     `none', no window is applied. Argument is case insensitive.
     Default is `Hamming'.


File: spro.info,  Node: Feature vector options,  Next: Miscellaneous options,  Prev: Framing options,  Up: Common options

3.2.3 Feature vector options
----------------------------

The following options are used to control the content of the output
feature vectors, enabling global normalizations and dynamic feature
computation:
`-Z, --cms'
`'
     Perform mean normalization.

`-R, --normalize'
`'
     Perform variance normalization. Variance normalization is only
     possible if `--cms' is also specified. Otherwise, an error is
     generated.

`-L, --segment-length=n'
`'
     Set normalization and energy scaling segment length. If this
     option is specified, mean, variance or max calculation is
     performed using a sliding window of `n' frames. Default is to
     calculate mean, variance or max globally when flushing the output
     buffer. This argument is ignored if neither `--cms' nor
     `--normalize' are specified.

`-D, --delta'
`'
     Add first order derivatives to the feature vector.

`-A, --acceleration'
`'
     Add second order derivatives to the feature vector. This is only
     possible if `--delta' is also specified. Otherwise, an error is
     generated.

`-N, --no-static-energy'
`'
     Remove static log-energy from the feature vector. This is only
     possible if `--delta' is also specified. Otherwise, an error is
     generated.


File: spro.info,  Node: Miscellaneous options,  Prev: Feature vector options,  Up: Common options

3.2.4 Miscellaneous options
---------------------------

Last but not least, here are some very practical options (specially the
second one):
`-v, --verbose'
`'
     Turn on verbose mode

`-h, --help'
`'
     Print a help message for the tool and exit.

`-V, --version'
`'
     Print version information and exit.


File: spro.info,  Node: I/O via stdin and stdout,  Next: Extracting features,  Prev: Common options,  Up: SPro tools

3.3 I/O via stdin and stdout
============================

Every SPro command requires that input and output files are explicitly
specified. However, in the very Unix philosophy, the special symbol `-'
(dash) can be used as input file to specify that input is to be read
from `stdin' or as output file to specify that output should be
directed to `stdout'.

   The use of standard input and output makes it possible to pipe the
SPro commands one after the other or even with external programs. The
example
     sfbcep foo.lin - |  scopy -o ascii - -
   illustrates the use of pipes to list the feature vectors directly
from the waveform file `foo.lin'. Another particularly useful example of
pipes with SPro commands is given in *note Waveform streams::.


File: spro.info,  Node: Extracting features,  Next: Manipulating features,  Prev: I/O via stdin and stdout,  Up: SPro tools

3.4 Extracting features
=======================

* Menu:

* Filter-bank analysis tools::  Tools for filter-bank derived features
* LPC analysis tools::          Tools for linear prediction derived features


File: spro.info,  Node: Filter-bank analysis tools,  Next: LPC analysis tools,  Prev: Extracting features,  Up: Extracting features

3.4.1 Filter-bank analysis tools
--------------------------------

The tools `sfbank' and `sfbcep' are dedicated to filter-bank based
speech analysis.

* Menu:

* Filter-bank magnitudes::      All about `sfbank'
* Filter-bank cepstrum::        All about `sfbcep'
* Filter-bank options::         `sfbank' and `sfbcep' options


File: spro.info,  Node: Filter-bank magnitudes,  Next: Filter-bank cepstrum,  Prev: Filter-bank analysis tools,  Up: Filter-bank analysis tools

Filter-bank log-magnitude features
..................................

The first filter-bank analysis tool, `sfbank', takes as input a
waveform and output filter-bank magnitude features. For each frame, the
FFT is performed on the windowed signal, possibly after zero padding,
and the magnitude is computed before being integrated using a triangular
filter-bank. *Note Filter-banks::, for mathematical details. To avoid
numerical problems, a threshold is used to keep channel log-magnitudes
positive or null. The signal bandwidth may be artificially limited by
specifying lower and higher frequencies using the `--freq-min' and
`--freq-max' options respectively. In this case, the central
frequencies of the filter-bank channels are regularly taken in the
specified bandwidth. Even if frequency warping is used, the lower and
upper frequencies are specified in the linear frequency domain, though,
of course, the filter's central frequencies will be taken regularly in
the transformed domain. Both MEL and bilinear frequency warping are
possible with `sfbank'.

   First and second order derivatives can be appended to the filter-bank
log-magnitude features using `--delta' and `--acceleration'
respectively.


File: spro.info,  Node: Filter-bank cepstrum,  Next: Filter-bank options,  Prev: Filter-bank magnitudes,  Up: Filter-bank analysis tools

Filter-bank cepstral features
.............................

The second filter-bank analysis tool, `sfbcep', takes as input a
waveform and output filter-bank derived cepstral features. The
filter-bank processing is similar to what is done in `sfbank' (see
previous section). The cepstral coefficients are computed by DCT'ing
the filter-bank log-magnitudes and possibly liftered.

   Optionally, the log-energy can be added to the feature vector. In
`sfbcep', the frame energy is calculated as the sum of the squared
waveform samples after windowing. As for the magnitudes in the
filter-bank, the log-energy are thresholded to keep them positive or
null. The log-energies may be scaled to avoid differences between
recordings.

   Mean and variance normalization of the static cepstral coefficients
can be specified with the global `--cms' and `--normalize' options but
do not apply to log-energies. The normalizations can be global
(default) or based on a sliding window whose length is specified with
`--segment-length'.

   Finally, first and second order derivatives of the cepstral
coefficients and of the log-energies can be appended to the feature
vectors. When using delta features, the absolute log-energy can be
suppressed using the `--no-static-energy' option.


File: spro.info,  Node: Filter-bank options,  Prev: Filter-bank cepstrum,  Up: Filter-bank analysis tools

Options
.......

The following options are available for both `sfbank' and `sfbcep'.
`-n, --num-filters=n'
`'
     Specify the number of channels in the filter bank. Default is 24.

`-a, --alpha=f'
`'
     Use bilinear frequency warping and set the warping parameter a to
     `f' (`f' must be between 0 and 1).  This option is incompatible
     with `--mel' and will be overwritten by the latter. Default is no
     warping.

`-m, --mel'
`'
     Use MEL frequency warping. This option overwrites the `--alpha'
     one as both are incompatible. Default is no warping.

`-i, --freq-min=f'
`'
     Specify band limiting and set the lower frequency bound to `f' Hz.
     Default is no band limiting.

`-u, --freq-max=f'
`'
     Specify band limiting and set the upper frequency bound to `f' Hz.
     Default is no band limiting.

`-b, --fft-length=n'
`'
     Set FFT length to `n' samples. The FFT length must be a power of
     two and greater than or equal to the number of samples in a frame.
     If FFT length is greater, the windowed frame samples are padded
     with zeroes before running the Fourier transform.

The following options are also available for `sfbcep'.
`-p, --num-ceps=n'
     Set the number of output cepstral coefficients to `n'. `n' must be
     less or equal to the number of channels in the filter bank.
     Default is 12.

`-r, --lifter=n'
     Set liftering parameter L to `n'. Default is no liftering.

`-e, --energy'
`'
     Add log-energy to the feature vector.

`-s, --scale-energy=f'
`'
     Scale energy according to e_t = 1 + f (e_t - max_t(e_t)). The way
     the maximum energy value is computed depends on whether
     `--segment-length' is specified or not.

`sfbank' supports the `--delta' and `--acceleration' options. In
addition, `sfbcep' also supports the `--cms' and `--normalize' options.
*Note Common options::, for a description of these options and for
additional ones.


File: spro.info,  Node: LPC analysis tools,  Prev: Filter-bank analysis tools,  Up: Extracting features

3.4.2 LPC analysis tools
------------------------

SPro provides two different tools, `slpc' and `slpcep', for linear
predictive analysis of speech signals.

* Menu:

* Linear prediction coefficients::  All about `slpc'
* Linear prediction cepstrum::  All about `slpcep'
* PLP cepstrum::                All about `splp'
* LPC Options::                 `slpc', `slpcep' and `splp' options


File: spro.info,  Node: Linear prediction coefficients,  Next: Linear prediction cepstrum,  Prev: LPC analysis tools,  Up: LPC analysis tools

Linear prediction coefficients
..............................

The tool `slpc' takes as input a waveform and output linear prediction
derived features. For each frame, the signal is windowed after
pre-emphasis and the generalized correlation is computed and further
used to estimate the reflection and the prediction coefficients which
can, in turn, be transformed into log area ratios or line spectrum
frequencies. *Note Linear prediction::, for mathematical details. The
default is to output the linear prediction coefficients however
reflection coefficients can be obtained with the `--parcor' option,
log-area ratios with `--lar' option and line spectrum pairs with the
`--lsp' one.

   Optionally, the log-energy can be added to the feature vector. In
`slpc', the log-energy is taken as the linear prediction filter gain,
which is also the variance of prediction error, and thresholded to be
positive or null.  The log-energies may be scaled to avoid differences
between recordings using the `--scale-energy' option.


File: spro.info,  Node: Linear prediction cepstrum,  Next: PLP cepstrum,  Prev: Linear prediction coefficients,  Up: LPC analysis tools

Linear prediction cepstrum
..........................

Program `slpcep' takes as input a waveform and outputs cepstral
coefficients derived from the linear prediction filter coefficients. The
linear prediction processing steps are as in `slpc' (see previous
section) and cepstral coefficients are computed from the linear
prediction coefficients using the recursion previously described. The
required number of cepstral coefficients must be less then or equal to
the prediction order.

   As for `slpc', the log-energy, taken as the gain of the linear
prediction filter, can be added to the feature vectors.

   Mean and variance normalization of the static cepstral coefficients
can be specified with the global `--cms' and `--normalize' options but
do not apply to log-energies. The normalizations can be global
(default) or based on a sliding window whose length is specified with
`--segment-length'.

   Finally, first and second order derivatives of the cepstral
coefficients and of the log-energies can be appended to the feature
vectors. When using delta features, the absolute log-energy can be
suppressed using the `--no-static-energy' option.


File: spro.info,  Node: PLP cepstrum,  Next: LPC Options,  Prev: Linear prediction cepstrum,  Up: LPC analysis tools

PLP cepstrum
............

Program `splp' takes as input a waveform and outputs cepstral
coefficients derived from a perceptual linear prediction analysis. Note
that, although not explicitely mentioned in the program name, `splp'
does output cepstral coefficients, not linear prediction coefficients.
The LPC order must be less than or equal to the number of filters in
the filter-bank while the number of cepstral coefficients must be less
than or equal to the prediction order.

   The log-energy is taken from the frame waveform as in the filter-bank
tools.


File: spro.info,  Node: LPC Options,  Prev: PLP cepstrum,  Up: LPC analysis tools

Options
.......

The following options are available for `slpc', `slpcep' and `splp'.
`-n, --order=n'
`'
     Specify the linear prediction analysis order. Default is 12.

`-a, --alpha=f'
`'
     Use bilinear frequency warping and set the warping parameter a to
     `f' (`f' must be between 0 and 1). Default is no warping.

`-e, --energy'
`'
     Add log-energy to the feature vector.

`-s, --scale-energy=f'
`'
     Scale energy according to e_t = 1 + f (e_t - max_t(e_t)). The way
     the maximum energy value is computed depends on whether
     `--segment-length' is specified or not.

The following options are specific to `slpc'.
`-r, --parcor'
     Output reflection coefficients rather than linear prediction
     coefficients.

`-g, --lar'
     Output log area ratios rather than linear prediction coefficients.

`-p, --lsp'
     Output line spectrum pairs rather than linear prediction
     coefficients.

The following options are also available for `slpcep' and `splp'.
`-p, --num-ceps=n'
     Set the number of output cepstral coefficients to `n'. `n' must be
     less or equal to the number of channels in the filter bank.
     Default is 12.

`-r, --lifter=n'
     Set liftering parameter L to `n'. Default is no liftering.

`splp' supports all of the options of `sfbank' for the control of the
filter-bank (number of filters, bandwidth, Mel frequency warping,
etc.). The power spectrum compression factor can be specified using
`--compress'.

Also, `slpcep' and `splp' support the `--cms' and `--normalize'
normalization options as well as `--delta' and `--acceleration'. *Note
Common options::, for a description of these options and for additional
ones.


File: spro.info,  Node: Manipulating features,  Prev: Extracting features,  Up: SPro tools

3.5 Manipulating feature streams
================================

SPro provides a tool, `scopy' for manipulating feature streams. More
than a mere copy tool, `scopy' also allows to normalize features, add
dynamic features, scale the features, apply a linear transformation to
the feature vectors and extract some components of the feature vector.
All of these operations are detailed below. In addition, `scopy' can
import feature files from previous SPro release, export files to alien
formats such as HTK, or view the content of an SPro feature file in
text format.

* Menu:

* Operations on feature streams::  Maniuplating feature streams with `scopy'
* Exporting features::          Exporting features to alien formats with `scopy'
* Importing from a previous SPro release::  Compatibility questions
* Copy options::                `scopy' options


File: spro.info,  Node: Operations on feature streams,  Next: Exporting features,  Prev: Manipulating features,  Up: Manipulating features

3.5.1 Operations on feature streams
-----------------------------------

As mentioned in the introduction, `scopy' may be used for
  a. mean and variance normalization,

  b. dynamic features computation,

  c. multiplicative scaling,

  d. linear transformation, and

  e. components extraction.

   The two first transformations, i.e. normalization and dynamic feature
computation, are actually done at once when loading the input features.
If normalization is specified, the static coefficients, not including
energy, are normalized before delta and acceleration features are
computed. If dynamic feature are used, the static log-energy can be
discarded using `--no-static-energy'. As in all the feature extraction
tools, normalization is either global or based on a sliding window,
depending on whether `--segment-length' was specified or not.

   Multiplicative scaling is a simple operation which consists in
multiplying every component of every feature vector by a scaling
factor. This is sometimes used to reduce the variance of features with a
high dynamic range in order to avoid numerical problems when computing a
linear transformation for those features or when doing some modeling.

   A linear transformation matrix can be specified using `--transform'
to project the input feature vectors according to y'(t) = A z(t), where
y'(t) is the transformed vector for frame t and z(t) is a column vector
containing the input feature frame y(t) plus possibly some context
frames(1). For example, assuming a context size k, z(t) will be the
concatenation of input feature vectors y(t-k) to y(t+k). If m is the
input feature dimension, possibly after adding the dynamic features if
this was asked, and n the output dimension, the transformation matrix
will have `nrows'=n rows and `ncols'=(2 k + 1) * m columns. The matrix
A is stored in a text file with the following syntax
     nrows ncols nsplice
     A[1][0]      A[1][1]   .........   A[1][ncols]
                             .........
     A[nrows][0]            .........   A[nrows][ncols]
   where `nsplice' is the context size.

   Component extraction consists in extracting some components of the
feature vectors. The extraction pattern is specified using the
`--extract=str' option where `str' is a comma separated list of
components to keep. The latter are specified either as a single
component index or as a index range using a dash (`-'). Component
indices start at 1. For example, the command
     scopy --extract=1-12,25-36 foo.prm bar.prm
   could be used to extract components 1 to 12 and 25 to 36 from
`foo.prm' into `bar.prm', which, one can imagine, would correspond to
keeping the 12 static features and the 12 acceleration features, thus
discarding the delta features.

   When performing either linear transformation or component extraction,
the content of the resulting feature vector can no longer be described
using a feature description flag. Indeed, specifying if a vector as
delta features after a linear transformation does make no sense. For
this reason, the output stream description flag will be arbitrarily set
to zero if at least one of this transformation is specified.

   If several operations are specified, they are applied in the order in
which they are listed above. Therefore, delta coefficients are computed
before the linear transformation if both are specified. As for now,
there is unfortunately no direct and easy way to change the order of
these operations. In particular, it is not possible to add delta
coefficients after linear transformation which is an operation that does
not seem illogical. The easiest, though CPU consuming, way to change the
processing order is to use `scopy' several times, possibly with pipes.
For example, the line
     scopy --transform=pca.mat foo.prm - | scopy -ZD - bar.prm
   will apply the linear transformation stored in file `pca.mat' to the
feature vectors in `foo.prm' (first `scopy') and then remove the mean
of the static features before adding the delta features and store the
result in `bar.prm' (second `scopy').

   ---------- Footnotes ----------

   (1) Frames are duplicated at the (buffer) boundaries.


File: spro.info,  Node: Exporting features,  Next: Importing from a previous SPro release,  Prev: Operations on feature streams,  Up: Manipulating features

3.5.2 Exporting features
------------------------

Exporting feature streams to alien formats is also possible with
`scopy'. Currently, three alien formats are supported, namely HTK(1),
Sirocco(2) and ASCII text format.

   Export to HTK and Sirocco file formats is only possible on seekable
streams, i.e. regular files in which the C function `fseek' works. The
reason for this constraint is that those formats include the number of
frames in the header. Since the number of frames is not in the SPro
header, `sopy' uses `fseek' to seek to the end of the input feature
stream in order to determine the number of frames. As a consequence, it
is not possible to export to one of these alien formats when reading
from a pipe. On the other hand, no seek in the output file is therefore
necessary and the output of `scopy' can be piped into another command.
This is particularly usefull with HTK, where setting the environment
variable `HPARMFILTER' to `scopy -o HTK $ -', enables to read directly
read SPro files with HTK. See section _"Input/Output via Pipes and
Networks"_ in the HTK 3.2 book for details.

   Export to ASCII is useful to list in a (almost) human-readable way
the content of a feature stream. In particular, combining the ASCII
output with the `--info' option which gives information about the
content of the input stream before possible transformation. For example,
the command
     scopy -zi -ZDA foo.prm -
   will produce the following output
     frame_rate = 100.00
     input_dimension = 12
     input_qualifiers = <nil>
     output_dimension = 36
     output_qualifiers = ZDA
In the above example, the input file dimension is 12 is then modified to
36 by adding the dynamic coefficients (`-ZDA'). Note that possible
transformations (e.g. linear transform, bin extraction) are _not_ taken
into account in the output dimension and qualifiers. For instance,
`scopy -zi -ZDA -x 1-3,7 foo.prm -' will still come up with the same
output as above.

   As mentioned in *note File formats::, SPro feature files are always
in little endian byte order. On the contrary, exported files are
written in the machine's natural byte order. As both HTK and Sirocco
expects files in big-endian byte order(3), the option `--swap' can be
used to swap the byte order before writing the file in alien file
formats. This option is ignored if the output file format is ASCII
(obviously) or SPro.

   ---------- Footnotes ----------

   (1) HTK is a popular Hidden Markov Model Toolkit from Cambridge
University, `http://htk.eng.cam.ac.uk'.

   (2) Sirocco is a free large vocabulary speech recognition search
engine, `http://gforge.inria.fr/projects/sirocco'

   (3) In HTK, this actually depends whether or not
`NATURALREADORDER=T' was specified in your configuration file.


File: spro.info,  Node: Importing from a previous SPro release,  Next: Copy options,  Prev: Exporting features,  Up: Manipulating features

3.5.3 Importing from a previous SPro release
--------------------------------------------

The option `--compatibility' is provided for compatibility and enables
to read feature files from previous versions of SPro (SPro 3.* and
before). When this option is used, the entire feature file is loaded
into memory at once as this used to be the case in previous versions.
Using this options with large files may therefore be quite memory
consuming (and slow by the same occasion). All the processing
capabilities (normalization, dynamic features, linear transform, etc.)
remains possible when importing files from previous SPro versions.


File: spro.info,  Node: Copy options,  Prev: Importing from a previous SPro release,  Up: Manipulating features

3.5.4 Copy options
------------------

The following options are available in `scopy':
`-c, --compatibility'
`'
     Turn on compatibility and set the input file format to former SPro
     format. Default is SPro 5.0 format.

`-I, --bufsize=n'
`'
     Set the I/O buffer size in kbytes. Default is 10 Mbytes. If
     `--compatibility' is specified, the specified buffer size applies
     only to the output buffer, the entire input data being loaded into
     memory.

`-i, --info'
`'
     Print stream information.

`-z, --suppress'
`'
     Suppress data output. If this option is turned on, no output is
     created. This option is provided mainly for use with `--info' in
     order to print the stream description flag or for diagnosis
     purposes.

`-B, --swap'
`'
     Swap byte order before writing new file. Byte swapping is only
     possible if the output format is either HTK or Sirocco (see
     `--output-format' below). Default is to use the machine's natural
     byte-order.

`-o, --output-format=str'
`'
     Set the output format, where `str' is one of `ascii', `htk' or
     `sirocco'. Default is the native SPro format.

`-m, --scale=f'
`'
     Scale features, multiplying them by the scaling factor `f'.

`-t, --transform=str'
`'
     Apply the linear transformation whose matrix is specified in file
     `str'.

`-x, --extract=str'
`'
     Extract the specified components of the feature vector. The
     argument `str' is a comma separated list of components to extract,
     where the components are specified either as a single index or a
     range of indices specified using a dash (`-'). The index of the
     first component is 1.

`-s, --start=n'
`'
     Start copying frames at frame index `n'. Frame numbers start with
     zero. Default is 0.

`-e, --end=n'
`'
     End copying at frame index `n' (included). Frame numbers start with
     zero. Default is to copy to the end of stream.


File: spro.info,  Node: SPro library,  Next: Reference guide,  Prev: SPro tools,  Up: Top

4 The SPro library
******************

This chapter describes the main functions of the SPro library and should
be sufficient for most implementations using the library. For more
details, the reader is invited to read the source code which is, and
will probably ever be, the most detailed and up-to-date description of
what a function does. In particular, the library header `spro.h' gives
a lot of details about functions arguments. The SPro tools(1) are good
example on the use of the library functions.

   Basic type definitions are voluntarily _not_ given in the manual.
Wherever necessary, "accessors" are given to access the most crucial
members of structured types and, unless not possible otherwise, direct
access should be avoided as much as possible in order to ensure a
better compatibility with future versions of the library. For sake of
rapidity, these accessors are mostly macros rather than functions. These
accessors are described in the relevant sections.

* Menu:

* Waveform streams::            Functions related to waveforms
* Feature description flags::   Describing feature vector contents
* Feature streams::             Reading and writing features
* Storing features without streams::  I/O with feature buffers
* Feature conversion::          Adding delta features, CMS, etc...
* FFT-based functions::         FFT analysis functions
* LPC-based functions::         LPC analysis functions
* Miscellaneous functions::     Whatever could not go anywhere else

   ---------- Footnotes ----------

   (1) Maybe to the exception of `scopy' which is a total mess.


File: spro.info,  Node: Waveform streams,  Next: Feature description flags,  Prev: SPro library,  Up: SPro library

4.1 Waveform streams
====================

This section describes functions related to waveforms, or equivalently
signals. From now on, the term signal will be used as a synonym to
waveform unless otherwise specified. Functions related to signals are
usually prefixed with `sig_' and located in `sig.c' and `misc.c'.

* Menu:

* Waveform memory allocation::  Memory allocation for waveforms
* Opening waveform streams::    Opening waveform streams for reading
* Reading frames::              Reading frames from a waveform stream
* Computing frame energy::      Computing frame energy


File: spro.info,  Node: Waveform memory allocation,  Next: Opening waveform streams,  Prev: Waveform streams,  Up: Waveform streams

4.1.1 Memory allocation
-----------------------

Waveforms, or signals, are stored in a variable whose type is
`spsig_t'. This type is not intended for storing waveform "streams",
i.e. the entire waveform for a document, but rather the frame samples.
Therefore, no I/O functions are provided for this data type. Every
signal processing function which operates on a frame takes as input a
variable of the type `spsig_t'. Memory allocation for a signal is
performed using `sig_alloc' and released using `sig_free'.

 -- Function: spsig_t * sig_alloc (unsigned long *N)
     Allocate memory for a signal containing N samples. Return a
     pointer to the allocated structure or `NULL' in case of error.

 -- Function: void sig_free (spsig_t *P)
     Free memory allocated for a signal using `sig_alloc'.


File: spro.info,  Node: Opening waveform streams,  Next: Reading frames,  Prev: Waveform memory allocation,  Up: Waveform streams

4.1.2 Opening streams
---------------------

Signals are usually read from a stream, i.e. a collection of samples,
from which the frames are made. As the SPro library has been designed to
process signals into feature vectors, signal streams are solely input
streams and no output function is provided. Therefore, a signal stream
is always opened in read mode. The following two functions are used to
open a stream for reading and to close the stream when all is done.
Reading frames from a stream is explained in the next section.

 -- Function: sigstream_t * sig_stream_open (const char *FN, int FMT,
          float FS, size_t NBYTES, int SWAP)
     Open stream in file FN in read mode, where the file format is FMT.
     If FN is `NULL', input will be made from `stdin'. Valid file
     formats are `SPRO_SIG_PCM16_FORMAT', `SPRO_SIG_ALAW_FORMAT',
     `SPRO_SIG_ULAW_FORMAT', `SPRO_SIG_WAVE_FORMAT' and
     `SPRO_SIG_SPHERE_FORMAT' if the library has been compiled to
     support the SPHERE file format. If FMT is `SPRO_SIG_PCM16_FORMAT',
     `SPRO_SIG_ALAW_FORMAT' or `SPRO_SIG_ULAW_FORMAT', the sample rate
     FS (in Hz) must be specified. Otherwise, the sample rate is read
     from the header and FS is ignored. The input buffer size is
     specified by NBYTES, which means NBYTES bytes will be allocated
     for input. If SWAP is non null, byte swapping is performed on the
     samples after reading them. Return a pointer to the opened signal
     stream or `NULL' in case of error.

 -- Function: void sig_stream_close (sigstream_t *F)
     Close a signal stream opened with `sig_stream_open', releasing
     allocated memory.


File: spro.info,  Node: Reading frames,  Next: Computing frame energy,  Prev: Opening waveform streams,  Up: Waveform streams

4.1.3 Reading frames
--------------------

Though possible, accessing directly samples in the stream is not the
purpose of signal streams in SPro. Indeed, speech processing is based on
the processing of successive overlapping frames. The library provides
function to access directly to frames, such as `get_next_sig_frame'
which returns frame samples which can be weighted using `sig_weight'.
Weighting vectors for standard signal processing windows are created
using `set_sig_win'.

 -- Function: int get_next_sig_frame (sigstream_t *F, int CH, int L,
          int D, float K, sample_t *BUF)
     Read next frame from channel CH in stream F. Frames are L samples
     long with a shift of D samples between successive frames. Frame
     samples are returned in the buffer BUF which must have been
     previously allocated to contain at least D samples. The content of
     BUF must be kept untouched between two successive calls since some
     of the samples reused due to the overlap. Argument K sets the
     pre-emphasis factor. Return 1 in case of success and 0 otherwise.

 -- Function: float * set_sig_win (unsigned long N, int TYPE)
     Allocate and initialize a weighting vector of length N for the
     specified window type, where TYPE is one of `SPRO_HAMMING_WINDOW',
     `SPRO_HANNING_WINDOW' and `SPRO_BLACKMAN_WINDOW'. The window type
     `SPRO_NULL_WINDOW' is defined for the purpose of argument
     processing but is not a valid argument for this function. Return a
     pointer to the allocated vector or `NULL' in case of error.

 -- Function: spsig_t * sig_weight (spsig_t *S, sample_t *BUF, float *W)
     Weight the samples in BUF according to the weights in W. The
     result is returned in the previously allocated signal S whose size
     must correspond to the buffer's length. Return a pointer S.

   The following is a typical piece of code used to open a signal stream
and loop on all the input frames of N samples every D samples(1).
     spfstream_t *f = sig_stream_open("foo.wav",
                                      SPRO_SIG_WAVE_FORMAT, 0, 10000, 0);
     spsig_t *frame = sig_alloc(N);
     float *w = set_sig_win(N, SPRO_HAMMING_WINDOW);
     sample_t *buf = (sample_t *)malloc(N * sizeof(sample_t));

     while (get_next_sig_frame(f, 1, N, D, 0.95, buf)) {
       sig_weight(frame, buf, w); /* weight signal */

       /* ... */

     }

     sig_stream_close(f);
     sig_free(frame);
     free(w);
     free(buf);

   ---------- Footnotes ----------

   (1) For increased readability, error checking has been removed from
the allocations.


File: spro.info,  Node: Computing frame energy,  Prev: Reading frames,  Up: Waveform streams

4.1.4 Computing frame energy
----------------------------

Assuming the frame signal is centered, `sig_normalize' compute the
frame energy and may perform energy normalization to unity.

 -- Function: double sig_normalize (spsig_t *S, int NORM)
     Return the square root of the sum of the squared samples in S. If
     NORM is not null, normalize the signal variance to unity.


File: spro.info,  Node: Feature description flags,  Next: Feature streams,  Prev: Waveform streams,  Up: SPro library

4.2 Feature description flags
=============================

Feature description flags are used to describe the content of a feature
vectors indicating information about mean and variance normalization,
delta features, etc. *Note Feature streams::, for details. In the
library, such flags are represented as field of bits, coded as `long'
integers. To avoid incomprehensible code, symbolic constants are
defined for each piece of information possibly encoded in the feature
description flag. Bit mask constants are of the form `WITHX', where `X'
is one of the letter `E', `Z', `R', `D', `A' or `N'. The constant
`SPRO_EMPTY_FLAG', equals to 0, can also be used to denote an empty
flag.

   The two functions `set_flag_bits' and `get_flag_bits' can be used to
raise or check the presence of elements (bits) in the flags.
Alternatively, logical operators can be used directly on the flag
value. For example, the instruction
     flag = flag | WITHZ;
   will raise the bit corresponding to mean subtraction while `flag &
WITHZ' will be true if the bit corresponding to `Z' is raised and false
otherwise. However, we recommend using the two macros for compatibility
purposes. Another way o set flags is via the function `sp_str_to_flag'
which converts a string of characters to a flag. The dual operation is
implemented in `sp_flag_to_str'.

 -- Macro: long set_flag_bits (long FLAG, long MASK)
     Set to one the bits specified by MASK in the the feature
     description flag FLAG. Return the resulting stream description
     flag. For example, the following line
            flag = set_flag_bits(flag, WITHZ | WITHR)
     will raise the bits `WITHZ' and `WITHR' in FLAG, corresponding to
     mean and variance normalization respectively. Bits already raised
     in FLAG will be left untouched.

 -- Macro: long get_flag_bits (long FLAG, long MASK)
     Return a flag containing the bits which are raised both in FLAG
     and in MASK. The macro can be used as a boolean expression.
     However, this can be tricky, particularly if MASK is a logical
     expression by itself. In this case, `get_flag_bits' will be true
     if at least two corresponding bits are raised in FLAG and MASK.
     For example, if MASK has the value `(WITHZ | WITHR)',
     `get_flag_bits' will return true if FLAG has either the `WITHZ' or
     `WITHR' bit raised, or, obviously, both. To check that both bits
     are raised, use the following test
            if (get_flag_bits(flag, WITHZ | WITHR) == (WITHZ | WITHR)) {
              /* ... */
            }

 -- Function: long sp_str_to_flag (const char *STR)
     Convert STR into a feature description flag, where STR is a string
     of description letters among `E', `Z', `R', `D', `A' or `N'.
     Return a flag where the bits corresponding to the letters in STR
     are raised.

 -- Function: char * sp_flag_to_str (long FLAG, char STR[7])
     Convert FLAG into a string containing the corresponding feature
     description letters. This function is mainly for tracing. Return a
     pointer to STR.


File: spro.info,  Node: Feature streams,  Next: Storing features without streams,  Prev: Feature description flags,  Up: SPro library

4.3 Feature streams
===================

This section describes the functions related to input and output of
feature vectors. The functions are divided into three categories, namely
opening a feature stream, reading and writing features from or to a
stream and seeking to a particular position in the stream. Feature
stream functions are usually prefixed by `spf_stream_' and are located
in `spf.c', `misc.c' and `header.c'.

* Menu:

* Opening feature streams::     Opening feature streams for I/O
* Reading and writing feature vectors::  Reading features from and writing features to streams
* Seeking into a stream::       Access a particular frame in a stream


File: spro.info,  Node: Opening feature streams,  Next: Reading and writing feature vectors,  Prev: Feature streams,  Up: Feature streams

4.3.1 Opening feature streams
-----------------------------

This section describes in detail feature streams open and close
mechanism. The section also explains how to access stream attributes,
such as fields in the variable length header or the frame rate for
streams in read mode.

* Menu:

* Conversion flags::            Dynamically converting features at I/O time
* Opening for I/O ::            Open a feature stream
* Accessing stream attributes::  What's the stream dimension, frame rate, etc...


File: spro.info,  Node: Conversion flags,  Next: Opening for I/O,  Prev: Opening feature streams,  Up: Opening feature streams

Conversion flags
................

In SPro, conversions such as adding dynamic features, normalization or
energy scaling are associated with streams since these are typically
global operations which cannot be carried out at the frame level. Such
conversions are indicated by a "conversion flag" which specifies how
the input data should be converted before output. In read mode, input
refers to the file content and output is what is returned from the read
function while, in write mode, input refers to the input of the write
function and output to the file content. The conversion flag is a flag
which indicates the processing that must be done between the input and
the output. The conversion flag is actually a feature description flag
containing the bits that should be raised in the output feature
description flag in addition to those already present in the input
description flag. For example, if the conversion flag takes the value
`(WITHZ|WITHA)' and the input feature description flag, e.g. as
specified in the header of an input file, is `(WITHZ|WITHD)', the
resulting feature description for the input stream will be
`(WITHZ|WITHD|WITHA)'.

   Though not coded as a flag, conversion in feature streams may include
energy scaling. As this is not coded in the stream header, one must be
careful not to specify scaling twice. Energy scaling conversion is
turned on using `set_stream_energy_scale'. In a very similar way, the
function `set_stream_seg_length' can be used to specify segmental
normalization or scaling. Both functions should be called between the
call to open and the first call to read or write, depending on the
stream mode, in order to be effective.

 -- Macro: float set_stream_energy_scale (spfstream_t *F, float S)
     Turn on energy scaling for stream F with a scale factor S. A null
     value of S disable energy scaling. This is the default value when
     the stream is opened. The function must be called after opening the
     stream and before any I/O operation on the stream. Return S.

 -- Macro: long set_stream_seg_length (spfstream_t *F, long LENGTH)
     Turn on segmental normalization and scaling for stream S with a
     segment length of LENGTH frames. A null value of LENGTH disable
     energy scaling. This is the default value when the stream is
     opened. The function must be called after opening the stream and
     before any I/O operation on the stream. Return LENGTH.


File: spro.info,  Node: Opening for I/O,  Next: Accessing stream attributes,  Prev: Conversion flags,  Up: Opening feature streams

Opening for I/O
...............

As opposed to signal streams, feature streams can be either in read or
write mode. Since the arguments are quite different in both cases, two
different functions are provided, namely `spf_input_stream_open' and
`spf_input_stream_open'. The function `spf_stream_close' is common to
input and output streams.

   Feature streams have very important attributes, such as the
dimension, the feature description flag, the frame rate or the variable
header, for which accessors are provided. Macros to access the most
important attributes are documented here under.

 -- Function: spfstream_t * spf_input_stream_open (const char *NAME,
          long FLAG, size_t NBYTES)
     Open a feature stream associated to file NAME for reading with an
     associated buffer of NBYTES bytes. Features read from NAME are
     converted according FLAG. See above for details on convertion
     flags. Return a pointer to the feature stream.

 -- Function: spfstream_t * spf_output_stream_open (const char *NAME,
          unsigned short DIM, long IFLAG, long CFLAG, float FS, const
          spfield_t *hd, size_t NBYTES)
     Open a feature stream associated to file NAME for writing with a
     buffer of NBYTES bytes. The input features, i.e. features added to
     the stream via `spf_stream_write', dimension is DIM with a
     corresponding feature description flag IFLAG and a frame rate of
     FS Hz.. Conversion between the input features and the actual
     features written to file is specified by CFLAG. See above for
     details on conversion flags. Fields in the variable length header
     can be added via a possibly `NULL' array of fields HD, where HD is
     a NULL terminated array of `{char *name; char *value;}' elements.
     See example below. Return a pointer to the feature stream.

 -- Function: void spf_output_stream_open (spfstream_t *F)
     Close feature stream F opened with one of the `spf_*_stream_open'
     function, releasing allocated memory.


File: spro.info,  Node: Accessing stream attributes,  Prev: Opening for I/O,  Up: Opening feature streams

Accessing stream attributes
...........................

Stream attributes, such as dimension, fields in the variable length
header, frame rate can be accessed using the following accessors.

 -- Macro: char * spf_stream_name (spfstream_t *F)
     Return a pointer to the filename associated with stream F. If the
     stream has no associated filename, i.e. I/O via `stdin' and
     `stdout', return NULL.

 -- Macro: float spf_stream_rate (spfstream_t *F)
     Return the frame rate in Hz for stream F.

 -- Macro: unsigned short spf_stream_dim (spfstream_t *F)
     Return the feature vector dimension for stream F. The dimension
     corresponds to the dimension of the feature vectors possibly after
     conversion if the stream has a conversion flag set. For input
     streams, the dimension is therefore the dimension of the feature
     vectors returned by `get_next_spf_stream' while, for output
     stream, the dimension is the dimension as in the output header.

 -- Macro: long spf_stream_flag (spfstream_t *F)
     Return the feature description flag for stream F. The returned
     flag is taken after conversion, if any. For input streams, the flag
     describes the feature vectors returned by `get_next_spf_stream'
     while, for output stream, the flag is the output header's flag.

 -- Macro: spfheader_t * spf_stream_header (spfstream_t *F)
     Return a pointer to the (possibly empty) variable length header for
     stream F.

 -- Function: char * spf_header_get (spfheader_t *HEADER, const char
          *NAME)
     Return a pointer to the value of the attribute NAME in HEADER.
     Return `NULL' if there are no attribute NAME.

 -- Function: char * spf_header_get (spfheader_t *HEADER, const char
          *NAME)
     Return a pointer to the value of the attribute NAME in HEADER.
     Return `NULL' if there are no attribute NAME.

 -- Function: int spf_header_add (spfheader_t *HEADER, const spfield_t
          *TAB)
     Add fields in TAB to HEADER, where TAB is a `NULL' terminated
     array of `{char *name; char *value;}' elements. For example, the
     following code
          spfheader_t *header = spf_header_init(NULL);
          spfield_t tab[] = {
            {"snr", "20 dB"},
            {"date", "July 29, 2003"},
            {NULL , NULL}
          };
          spf_header_add (header, tab);
     would create an empty header (undocumented function
     `spf_header_init') and add the two fields `snr' and `date' to the
     header along with the corresponding values. No control is
     performed over duplicate field names. If several fields with the
     same name are added, the first one will always be returned by
     `spf_header_get' and the remaining one ignored. Return the number
     of fields added to the header.


File: spro.info,  Node: Reading and writing feature vectors,  Next: Seeking into a stream,  Prev: Opening feature streams,  Up: Feature streams

4.3.2 Reading and writing feature vectors
-----------------------------------------

The functions documented in this section are provided to read from or
write to feature streams. Reading can be done in one of two ways. You
can either read vector by vector using `get_next_spf_vec' or read in at
once all the data in the feature buffer using `spf_stream_read'.
Writing can only be done vector by vector using `spf_stream_write',
unless accessing directly the stream buffer. *Note Storing features
without streams::, for details on this highly not recommended
operation. In write mode, the feature are actually written to the
output file when the buffer is full or when the stream is closed.
However, function `spf_stream_flush' can be used to force the output to
file by flushing the buffer.

   Note that the two functions `spf_stream_read' and `spf_stream_write'
are actually not dual functions. The first one fills in the buffer with
as much data as possible while the second one writes some feature
vectors in the stream buffer.

 -- Function: unsigned long spf_stream_read (spfstream_t *F)
     Fill in stream F buffer, reading until the buffer is full or the
     end of stream. Return the number of frames read.

 -- Function: spf_t * get_next_spf_vec (spfstream_t *F)
     Return a pointer to the next feature vector in stream F or `NULL'
     at the end of stream. *Note Seeking into a stream::, for details
     on how to get a particular vector in the stream.

 -- Function: unsigned long spf_stream_write (spfstream_t *F, spf_t
          *BUF, unsigned long N)
     Write N feature vectors concatenated in BUF to stream F. The
     feature vector dimension in BUF is the dimension specified when
     the stream was opened. Return the number of frames written.

 -- Function: unsigned long spf_stream_flush (spfstream_t *F)
     Flush the buffer of stream F, forcing the feature vectors to be
     actually written to the output file. Flushing has no effect on
     input streams. Return the number of frames written.


File: spro.info,  Node: Seeking into a stream,  Prev: Reading and writing feature vectors,  Up: Feature streams

4.3.3 Seeking into a stream
---------------------------

The I/O functions described above are mainly intended for linear input
and output, i.e. for reading or writing feature vectors in a sequential
way. Though this is the most common case in speech processing,
accessing a particular feature vector directly is also very useful.
Functions to seek to a specified feature vector in a stream are
provided. Feature vectors are indexed starting from 0. In read mode,
seeking to a particular frame N using `spf_stream_seek' means that a
pointer to frame N is returned by the next call to `get_next_spf_vec'.
In write mode, the next call to `spf_stream_write' will start writing
at frame N, thus overwriting frame N and possibly the following if
those frames add already been set.

 -- Function: int spf_stream_seek (spfstream_t *F, long OFFSET, int
          WHENCE)
     Seek OFFSET frames according to WHENCE in stream F. The WHENCE
     argument is similar to the last argument of the C function `fseek'
     and specifies the reference point for OFFSET. If WHENCE is equal
     to `SEEK_SET' (0), OFFSET is relative to the first frame. If
     WHENCE is equal to `SEEK_CUR' (1), OFFSET is relative to the
     current frame in the stream. Positioning relative to the end of
     the stream is not possible since the stream length is not known.
     The offset can be positive to seek forward in time or negative to
     seek backward. Seeking is only possible if the file associated
     with F is a seekable device, which is not the case of `stdout' or
     `stdin'. Return 0 if seek was correct or an error code
     (`SPRO_STREAM_SEEK_ERR') otherwise.

 -- Macro: unsigned long spf_stream_tell (spfstream_t *F)
     Return the current position, i.e. frame index, in F.

 -- Macro: int spf_stream_rewind (spfstream_t *F)
     Seek to the beginning of the stream. This is equivalent to
     `spf_stream_seek(f, 0, SEEK_SET)'. Return 0 upon success.


File: spro.info,  Node: Storing features without streams,  Next: Feature conversion,  Prev: Feature streams,  Up: SPro library

4.4 Storing features without streams
====================================

In some programs, one may find useful to compute and keep in memory
feature vectors inside a program without accessing the disk. This is for
example the case if you want to embed feature extraction into your own
program. Feature streams are of course not adapted to such operations
which should rely on the use of "feature buffers" to store the feature
vectors. Feature buffers are buffers containing a collection of feature
vectors of the same dimension. Nearly no accessors are available for
the buffer structure `spfbuf_t' whose attributes can be referenced
directly. The structure definition is as follows:
     typedef struct {
       unsigned short adim;          /* allocated vector dimension     */
       unsigned short dim;           /* actual vector dimension        */
       unsigned long n;              /* number of vectors              */
       unsigned long m;              /* maximum number of vectors      */
       spf_t *s;                     /* pointer to features            */
     } spfbuf_t;
   Note that the allocated dimension may not be the actual dimension of
the features stored in the buffer. In particular, this is useful for
feature conversions. *Note Feature conversion::. The attribute `m' is
the maximum number of vectors of dimension `adim' that can be stored in
the buffer. Feature vectors are stored concatenated in the feature
"array" `s'. Scanning the buffer vectors, using the `adim', is
illustrated in an example below.

* Menu:

* Buffer allocation::           Allocating memory for a buffer
* Accessing buffer elements::   Accessing vectors in a buffer
* Buffer I/O::                  Reading and writing buffers to disk
* Buffers and streams::         Direct access to stream buffers (not recommended)


File: spro.info,  Node: Buffer allocation,  Next: Accessing buffer elements,  Prev: Storing features without streams,  Up: Storing features without streams

4.4.1 Buffer allocation
-----------------------

Functions are provided to allocate a buffer of a given size in bytes,
resize for a given number of feature vectors and free a buffer.

 -- Function: spfbuf_t * spf_buf_alloc (unsigned short DIM, size_t SIZE)
     Allocate memory for a buffer of SIZE bytes. The maximum dimension
     of the elements in the buffer is DIM, the maximum number of
     vectors in the buffer being determined according to DIM and SIZE.
     If SIZE is null, an empty buffer is allocated with the buffer
     array (`buf->s') set to `NULL'. Return a pointer to the allocated
     buffer.

 -- Function: spf_t * spf_buf_resize (spfbuf_t *BUF, unsigned long N)
     Resize buffer BUF to contain exactly N vectors. The buffer array
     is extended (resp. reduced) if N is more (resp. less) than the
     current buffer size. In both cases, the current content of the
     buffer is left unchanged. If the current buffer is empty (size is
     0 and array is `NULL'), the buffer array is allocated. This
     function can therefore be used to allocate a buffer for a given
     number of vectors rather than for a given size in bytes as in
     `spf_buf_alloc'. The following code is an example for allocating a
     buffer of 1000 feature vectors of dimension 33 using
     `spf_buf_resize'.
          spfbuf_t *buf = spf_buf_alloc(33, 0); /* alloc. empty buffer  */
          spf_buf_resize(&buf, 1000);           /* resize for 1000 vectors */
     Return the address of the first element of the buffer array. Note
     that the attribute `buf->s' may be changed in `spf_buf_resize'.

 -- Function: void spf_buf_free (spfbuf_t *BUF)
     Free memory allocated to BUF.


File: spro.info,  Node: Accessing buffer elements,  Next: Buffer I/O,  Prev: Buffer allocation,  Up: Storing features without streams

4.4.2 Accessing buffer elements
-------------------------------

The best way to reach a particular vector in a buffer is to grab a
pointer to the vector using `get_spf_buf_vec'. In addition, the
function `spf_buf_append' can be used to append feature vectors to a
buffer, possibly extending the buffer size if necessary.

 -- Function: spf_t * get_spf_buf_vec (spfbuf_t *BUF, unsigned long
          INDEX)
     Return a pointer to vector INDEX in BUF. As opposed to positions
     in feature streams, the frame index INDEX here is relative to the
     buffer, starting at 0. Return NULL if INDEX is out of bound.

 -- Function: spf_t * spf_buf_append (spfbuf_t *BUF, spf_t *V, unsigned
          short DIM, unsigned long NMORE)
     Append feature vector V of dimension DIM to buffer. If the buffer
     is full and NMORE is not null, the buffer maximum size is extended
     by NMORE vectors. Otherwise, if NMORE is null, the buffer is left
     unchanged and `NULL' is returned. If the buffer is empty, the
     input vector dimension DIM will be checked upon the buffer
     dimension. Else, DIM will be used to initialize the buffer
     dimension. In any case, DIM must be less than or equal to the
     maximum dimension (`buf->adim') for which the buffer has been
     allocated. Return a pointer to the appended vector in the buffer or
     `NULL' in case of error.

   Access to the buffer elements via `get_spf_buf_vec' implies a
multiplication. Scanning all the vectors in the buffer may result faster
using a pointer to the buffer array which is recursively incremented.
The following example illustrates this method and print to `stdout' the
feature vectors in text format.
     unsigned long i;
     unsigned short j;
     spf_t *p;

     p = buf->s;

     for (i = 0; i < spf_buf_length(buf); i++) {

       /* print vector at index i */
       fprintf(stdout, "index %lu", i);
       for (j = 0; j < spf_buf_dim(buf); j++)
         fprintf(stdout, " %8.4f", *(p+j));
       fprintf(stdout, "\n");

       /* move to next vector */
       p += buf->adim;
     }
   Note that the pointer increment is the allocated dimension `adim',
not the actual dimension `dim'. This example also illustrates the use
of the two accessors macros `spf_buf_length' and `spf_buf_dim' which
return the actual number of elements in the buffer and the actual
feature vector dimension respectively.


File: spro.info,  Node: Buffer I/O,  Next: Buffers and streams,  Prev: Accessing buffer elements,  Up: Storing features without streams

4.4.3 Buffer I/O
----------------

If you need the following functions to read or write the content of a
buffer to disk, you should be wondering why you are not using feature
streams for I/Os! Feature buffers are provided to store features in the
memory not for I/Os, for which using the feature streams, dedicated to
this purpose, should always be preferred. Still want to use buffer for
I/Os?

   Ok, but don't say you have not been warned! In case you insist on
buffer I/Os, the two functions `spf_buf_read' and `spf_buf_write' are
provided respectively to read the buffer content from disk or to write
the buffer content to disk.

 -- Function: unsigned long spf_buf_read (spfbuf_t *BUF, FILE *F)
     Read data from file F into the buffer, until the buffer maximum
     sized is reached or until the end of file, whichever occurs first.
     The vector dimension is taken from the buffer actual dimension
     given by `buf->dim'. Return the number of vectors read into the
     buffer.

 -- Function: unsigned long spf_buf_write (spfbuf_t *BUF, FILE *F)
     Write the content of BUF to file F. Return the number of vectors
     actually written to file.


File: spro.info,  Node: Buffers and streams,  Prev: Buffer I/O,  Up: Storing features without streams

4.4.4 Buffers and streams
-------------------------

In feature streams, I/O functions clearly make use of a feature buffer.
Accessing directly the element of the stream buffer using the buffer
functions described above is therefore possible. A pointer to the
stream buffer can be obtained using `spf_stream_buf'.

 -- Macro: spfbuf_t * spf_stream_buf (spfstream_t *F)
     Return a pointer to the buffer of stream F.

   Unless you are quite familiar with SPro programming, *direct access
to stream buffers is strongly discouraged* since direct buffer I/Os may
result in corrupted stream position information. The main consequence
of corrupted stream position information is that `spf_stream_seek' and
`spf_stream_tell' will not work properly. Rather than direct access to
the stream buffer, the use of `spf_stream_seek' and
`get_next_spf_frame' to access a particular vector should always be
preferred.


File: spro.info,  Node: Feature conversion,  Next: FFT-based functions,  Prev: Storing features without streams,  Up: SPro library

4.5 Feature conversion
======================

"Feature conversion" is the process of modifying the feature
description flag, for example, by normalizing the feature mean and
variance or by adding dynamic features. In other word, converting
features consist on modifying the input features to match a specified
target feature description. *Note Feature description flags::.

   Changing the feature type, e.g. converting feature bank features to
cepstral coefficients, is not considered as a feature conversion and is
outside the scope of the function described in this section. *Note
LPC-based functions::, for details about changing the the feature type
between various LPC representation. *Note FFT-based functions::, for
details about changing the filter-bank representation..

   Feature conversions are global operations in the sense that the
conversion applies to a collection of feature vectors rather than to
isolated feature vectors. Therefore, the conversion function,
`spf_buf_convert', operates on a feature buffer, modifying at once all
the buffer vectors and returning a buffer (possibly the same -- see
below) containing the new features.  The conversion itself is as follows
  a. copy static features into the output buffer, possibly excluding
     energy if required.

  b. normalize mean and variance of the static features in the output
     buffer (energy, if present, is not normalized) if required

  c. compute delta features for the output buffer if required

  d. compute acceleration features for the output buffer if required

  e. Since conversion principally aims at normalizing the features and
adding dynamic features, the latter are always recomputed from the
static features, even if the input feature vectors already contain
dynamic features. This means that, for example, when converting
features with a description flag value of `WITHE|WITHD' to
`WITHE|WITHD|WITHN', delta features will be recomputed, even though
this is not strictly necessary(1)!

   Conversion can operate under three different modes, namely duplicate,
replace and update. In duplicate mode, `spf_buf_convert' allocates the
output buffer and leaves the input buffer unchanged. This mode can be
used to duplicate a buffer, hence the name. In replace mode,
`spf_buf_convert' allocates the output buffer and releases memory
allocated for the input buffer, thus replacing somehow the input buffer
by the output one. Note that due to reallocation, the buffer address may
have changed after the call to `spf_buf_convert'. In replace mode,
calls to the conversion functions should therefore always look like
     buf = spf_buf_convert(buf, SPRO_EMPTY_FLAG, WITHD, 0,
                           SPRO_CONV_REPLACE);
   for the caller function to take into account the new address for
`buf'. Finally, in update mode, the output buffer is the same as the
input one and conversion is done "in place". For this, buffer maximum
dimension must be at least equal to the maximum of the input and output
dimensions. Otherwise update conversion is impossible and an error is
returned. In any of the three mode, `spf_buf_convert' returns a pointer
to the output buffer.

 -- Function: spf_t * spf_buf_convert (spfbuf_t *BUF, long IFLAG, long
          OFLAG, unsigned long WL, int MODE)
     Convert feature vectors in BUF from IFLAG description to OFLAG.
     The normalization window length WL specifies the length for
     segmental normalization. If null, global normalization is
     performed. Otherwise, use a sliding window of WL frames centered
     around the current frame. The mode is either `SPRO_CONV_DUPLICATE',
     `SPRO_CONV_REPLACE', `SPRO_CONV_UPDATE'. Return a pointer to the
     buffer containing the converted data.

   In addition to `spf_buf_convert', the function `spf_buf_normalize'
can be used to normalize the mean and variance of the features in a
buffer.  Similarly, the (fragile) function `spf_delta_set' can be used
to compute the derivatives of some features in a buffer. Both functions
are "generic" functions which should be used solely for the purpose of
non-standard operations. For example, normalizing the dynamic features
or the energy variance is not possible with `spf_buf_convert' but is
possible with `spf_buf_normalize'. Though not exactly a conversion
function, `scale_energy' is a generic function used to scale the energy
coefficients in a buffer.

 -- Function: int spf_buf_normalize (spfbuf_t *BUF, unsigned short S,
          unsigned short E, unsigned long WL, int VNORM)
     Normalize features S to E included in BUF, where S and E are bins
     in the feature vectors and starts at 0. If VNORM is non null,
     variance normalization is performed in addition to mean
     subtraction. The normalization window length WL specifies the
     length for segmental normalization. If null, global normalization
     is performed. Otherwise, use a sliding window of WL frames centered
     around the current frame. Return 0 upon success or an error code
     otherwise.

 -- Function: int spf_delta_set (spfbuf_t *IBUF, unsigned short IN_K,
          unsigned short D, spfbuf_t *OBUF, unsigned short OUT_K)
     Compute derivatives of features in the input buffer IBUF, from bin
     IN_K for D bins, writing the result from bin OUT_K in the output
     buffer OBUF. The output buffer can be the same as the input buffer
     and must have been properly allocated. This function is fragile as
     no mermory check is performed. It is therefore not exported and
     one should rather use `spf_buf_convert' directly. Should you
     require this function, you need to define `_convert_c_' before the
     inclusion of `spro.h'.

 -- Function: int scale_energy (spfbuf_t *BUF, unsigned short J, float
          S, unsigned long WL)
     Scale feature at bin J in BUF by the factor S. This function is
     intended for log-energy scaling and scales with respect to the
     maximum value. If WL is non null, segmental scaling using a
     sliding window of WL frames is done. Return 0 upon success.

   ---------- Footnotes ----------

   (1) This will probably change in future versions where we should try
to reuse as much as possible of the input features. Meanwhile, you will
have to do with things the way they are...


File: spro.info,  Node: FFT-based functions,  Next: LPC-based functions,  Prev: Feature conversion,  Up: SPro library

4.6 FFT-based functions
=======================

This section documents all the functions related to Fourier analysis of
speech signals.

* Menu:

* Fourier transform::           Fast Fourier transform of a signal
* Filter-bank::                 Filter-bank integration
* Cosine transform::            Discrete Cosine Transform


File: spro.info,  Node: Fourier transform,  Next: Filter-bank,  Prev: FFT-based functions,  Up: FFT-based functions

4.6.1 Fourier transform
-----------------------

SPro implements a fast Fourier transform (FFT) algorithm as described in
`P. Duhamel and M. Vetterli, Improved Fourier and Hartley Transform
Algorithms: Application to CycliC Convolution of Real Data, IEEE Trans.
on ASSP, 35(6), June 1987'. For sake of rapidity, the implementation is
based on a pre-computed FFT kernel which is initialized by `fft_init'.
Initializing the FFT kernel for a given FFT size is necessary before
the first invocation of `fft'. In particular, this implicates that the
kernel should be reinitialized whenever the FFT size changes. Memory
allocated to the kernel is released using `fft-reset'.

 -- Function: int fft_init (unsigned long N)
     Initialize the FFT kernel for length N. If N is null, reset the
     kernel. Otherwise (re)allocate a kernel for the specified length:
     if the kernel had previously been allocated with a different size
     and not reset, it is reallocated. Return 0 upon success.

 -- Function: int fft (spsig_t *S, float *MOD, float *PHI)
     Fourier transform of signal S using the current kernel. If the
     length of S is less than the kernel size, S is padded with zeros.
     On the contrary, if the length of S is more than the kernel size,
     S is truncated. Note that no warning occurs in this case. Return
     the modulus in MOD and the phase in PHI. Both MOD and PHI must
     have been allocated to contain at least N/2 elements, where N is
     the kernel size. Either one can be `NULL', in which case no value
     is returned. Return 0 upon success.

 -- Macro: int fft_reset ()
     Reset memory allocated to the FFT kernel. This is a macro to
     `fft_init(0)' which always returns 0.


File: spro.info,  Node: Filter-bank,  Next: Cosine transform,  Prev: Fourier transform,  Up: FFT-based functions

4.6.2 Filter-bank
-----------------

Filter-bank analysis is a two step process. The first step consists in
defining the filter-bank geometry, either with `set_mel_idx' or
`set_alpha_idx'. Both functions set the indices in the FFT magnitude
vector of the filters' cutoff frequencies according to the specified
frequency warping. The second step is the Fourier transform and the
filter-bank integration embedded in function `log_filter_bank'. Using
`log_filter_bank' requires that the FFT kernel has been initialized
previously.

 -- Function: unsigned short set_mel_idx (unsigned short *N, float
          FMIN, float FMAX, float FS)
     Set cutoff frequencies indices for N filters in the bandwidth FMIN
     -- FMAX, according to MEL frequency warping. Lower and upper
     frequency bounds, FMIN and FMAX are normalized frequencies between
     0 and 0.5. If FMAX is lower than or equal to FMIN, the upper bound
     will be considered to be the Nyquist frequency (1/2). The signal
     sample rate FS is given in Hz. Return a vector of N+2 indices or
     `NULL' in case of error.

 -- Function: unsigned short set_alpha_idx (unsigned short *N, float A,
          float FMIN, float FMAX)
     Set cutoff frequencies indices for N filters in the bandwidth FMIN
     -- FMAX, according to the bilinear frequency warping specified by
     A. If A is null, no frequency warping is used. Lower and upper
     frequency bounds, FMIN and FMAX, are normalized frequencies
     between 0 and 0.5. If FMAX is lower than or equal to FMIN, the
     upper bound will be considered to be the Nyquist frequency (1/2).
     Return a vector of N+2 indices or `NULL' in case of error.

 -- Function: int filter_bank (spsig_t *S, unsigned short N, unsigned
          short *IDX, int USEPOWER, int USELOG, spf_t *E)
     Apply N channel triangular filter-bank to signal S. The indices in
     the FFT module vector of the channels cutoff frequencies are given
     in IDX, which should have been initialized with one of the
     `set_*_idx' functions above. Depending on the two boolean flags
     USEPOWER and USELOG, the power or the magnitude spectrum or
     log-spectrum can be computed and returned in vector E, previously
     allocated to contain at least N elements. Return 0 upon success.

 -- Macro: int log_filter_bank (spsig_t *S, unsigned short N, unsigned
          short *IDX, spf_t *E)
     This function is a macro to `filter_bank' which returns the log of
     the magnitude spectrum. The use of `log_filter_bank' is deprecated
     and is solely provided for sake of compatibility with previous
     versions of SPro.

 -- Function: double * set_loudness_curve (unsigned short N, unsigned
          short *IDX, float FS)
     Allocate memory and initialize a loudness equalization filter for
     N filters. Centre frequencies of the filters are determined from
     the indexes IDX, obtained from one of the `set_*_idx' functions,
     and converted in Hertz assuming a signal sample rate of FS.


File: spro.info,  Node: Cosine transform,  Prev: Filter-bank,  Up: FFT-based functions

4.6.3 Cosine transform
----------------------

As for the Fourier transform, discrete cosine transform (DCT) is a
kernel based transformation. A DCT kernel for a given size is
initialized using `dct_init' while the transformation itself is carried
out by `dct'. The macro `dct_reset' resets the kernel.

 -- Function: int dct_init (unsigned short N, unsigned short M)
     Initialize the DCT kernel for a transformation from dimension N to
     M. If either N or M is null, reset the kernel. Otherwise
     (re)initialize a kernel for the specified transformation.length.
     Return 0 upon success.

 -- Function: int dct (spf_t *X, spf_t *Y)
     Apply transformation to X, storing the result in Y. Assuming the
     kernel was initialized with lengths N and M, X should contain at
     least N elements and Y must have been previously allocated to
     contain at least M elements. Return 0 upon success.

 -- Macro: int dct_reset ()
     Reset memory allocated to the FFT kernel. This is a macro to
     `dct_init(0, 0)' which always returns 0.


File: spro.info,  Node: LPC-based functions,  Next: Miscellaneous functions,  Prev: FFT-based functions,  Up: SPro library

4.7 LPC-based functions
=======================

This section documents functions related to LPC analysis of speech
signals. The first part documents how to solve the LPC equations while
the second one deals with transforming the LPC or PARCOR representation
into a different one.

* Menu:

* Linear prediction::           Computing linear prediction coefficients
* LPC conversion::              Conversions between LPC, LAR, PARCOR and LSF


File: spro.info,  Node: Linear prediction,  Next: LPC conversion,  Prev: LPC-based functions,  Up: LPC-based functions

4.7.1 Linear prediction
-----------------------

Linear prediction is a two step process in which the first step is to
compute the generalized correlation sequence (`sig_correl') before
solving the normal equations with LPC to obtain the prediction and
reflection coefficients.

 -- Function: int sig_correl (spsig_t *S, float A, float *R, unsigned
          short P)
     Compute generalized correlation for S according to the warping
     specified by A. If A is null, the autocorrelation is used. Return
     a correlation sequence of length P+1 via the previously allocated
     vector R. Return 0 upon success.

 -- Function: void lpc (float *R, unsigned short P, spf_t *A, spf_t *K,
          float *E)
     Compute P prediction and reflection coefficients given the
     correlation sequence R(0) to R(P). Return the prediction
     coefficients in A, the reflection coefficients in K and the LPC
     filter gain in E. Both A and K must have been previously allocated
     to contain at least P elements while E is a pointer to a `float'
     scalar.


File: spro.info,  Node: LPC conversion,  Prev: Linear prediction,  Up: LPC-based functions

4.7.2 LPC conversion
--------------------

Linear prediction can be converted into line spectrum frequencies
(`lpc_to_lsf') and LP-derived cepstral coefficients (LPC_TO_CEP).
Reflection coefficients are converted into log-area ratio using
`refc_to_lar'.

 -- Function: int lpc_to_lsf (spf_t *A, unsigned short P, spf_t *LSF)
     Convert P linear prediction coefficients A into line spectrum
     frequencies. LSF must have been previously allocated to contain at
     least P elements. Return 0 upon success.

 -- Function: void lpc_to_cep (spf_t *A, unsigned short P, unsigned
          short N, spf_t *C)
     Convert P linear prediction coefficients A into N cepstral
     coefficients C. C must have been previously allocated to contain
     at least N elements.

 -- Function: void refc_to_lar (spf_t *K, unsigned short P, spf_t *G)
     Convert P reflection coefficients K into P log area ratios G. G
     must have been previously allocated to contain at least P elements.


File: spro.info,  Node: Miscellaneous functions,  Prev: LPC-based functions,  Up: SPro library

4.8 Miscellaneous functions
===========================

This section documents a bunch of very useful functions. The two
functions `spf_indexes' and `spf_tot_dim' are dedicated to manipulating
the content of a feature vector. A feature vector contains various
elements characterized by the description flag. `spf_indexes' lets you
find out where the indices of the various elements in a feature vector
given the description flag while `spf_tot_dim' computes the feature
vector total dimension from the dimension of the static coefficients
and the description flag.

   The function `set_lifter' is a utility functions that allocates
memory for a lifter vector and initializes the vector according to the
lifter parameter.

 -- Function: void spf_indexes (unsigned short IDX[9], unsigned short
          DIM, long FLAG)
     Set in IDX the indices of each element characterizing a feature
     vector of dimension DIM with a description FLAG. IDX is a nine
     element vector containing indices in the feature vector and
     organized as follow
          <    static     ><E><      delta    ><dE>< delta delta  ><ddE>
          |   |  ...  |   |   |   |  ...  |   |   |   |  ...  |   |   |
            ^           ^   ^   ^           ^   ^   ^           ^   ^
            |           |   |   |           |   |   |           |   |
          idx[0]      idx[1]| idx[3]      idx[4]| idx[6]      idx[7]|
                            |                   |                   |
                          idx[2]              idx[5]              idx[8]
     For example, the index of the energy feature in the feature vector
     is IDX[2] while the index of the first delta feature in the feature
     vector is given by IDX[3]. With the exception of IDX[0] which
     should always be equal to 0, an index value of 0 means that an
     element is not present in the feature vector. For example, a call
     to
          spf_indexes(idx, 25, WITHE | WITHD | WITHN)
     would return the following index vector
          idx = { 0, 11, 0, 12, 23, 24, 0, 0, 0 }
     Assuming P is a pointer to a feature vector, the 12 static
     features range from P[0] to P[11], no static log-energy is present
     (`WITHN'), delta features are from P[12] to P[23] and delta
     log-energy can be accessed at P[24].

 -- Function: unsigned short spf_tot_dim (unsigned short SDIM, long
          FLAG)
     Return the feature vector total dimension given the dimension of
     the static coefficients SDIM (excluding energy) and the feature
     description FLAG.

 -- Function: float  * set_lifter (int L, unsigned short N)
     Return a pointer to a vector containing N coefficients for a
     lifter of parameter L.


File: spro.info,  Node: Reference guide,  Next: Changes,  Prev: SPro library,  Up: Top

5 Quick reference guide
***********************

This chapter is meant as a reference guide for all the SPro tools,
summarizing the syntax, synopsis and options. This is actually a printed
version of the online help message obtained with `--help'.

* Menu:

* sfbank::                      `sfbank' reference
* sfbcep::                      `sfbcep' reference
* slpc::                        `slpc' reference
* slpcep::                      `slpcep' reference
* splp::                        `splp' reference
* scopy::                       `scopy' reference


File: spro.info,  Node: sfbank,  Next: sfbcep,  Prev: Reference guide,  Up: Reference guide

5.1 `sfbank'
============

* Menu:

* sfbank usage::                Syntax
* sfbank synopsis::             Brief description
* sfbank options::              Options


File: spro.info,  Node: sfbank usage,  Next: sfbank synopsis,  Prev: sfbank,  Up: sfbank

Usage
-----

`sfbank [options] ifile ofile'


File: spro.info,  Node: sfbank synopsis,  Next: sfbank options,  Prev: sfbank usage,  Up: sfbank

Synopsis
--------

Filter bank analysis of the input signal.


File: spro.info,  Node: sfbank options,  Prev: sfbank synopsis,  Up: sfbank

Options
-------

`-F, --format=str'
`'
     Specify the input waveform file format. Available formats are
     `PCM16', `ALAW', `ULAW', `wave' or `sphere'. Default: `PCM16'.

`-f, --sample-rate=f'
`'
     Set input waveform sample rate to `f' Hz for `PCM16', `ALAW' or
     `ULAW' waveform files. Default: 8 kHz.

`-x, --channel=n'
`'
     Set the channel to consider for feature extraction. Default: 1.

`-B, --swap'
`'
     Swap the input waveform samples.

`-I, --input-bufsize=n'
`'
     Set the input buffer size to `n' kbytes. Default: 10 Mb.

`-O, --output-bufsize=n'
`'
     Set the output buffer size to `n' kbytes. Default: 10 Mb.

`-H, --header'
`'
     Output variable length header.

`-k, --pre-emphasis=f'
`'
     Set the pre-emphasis coefficient to `f'. Default: 0.95.

`-l --length=f'
`'
     Set the analysis frame length to `f' ms. Default: 20.0 ms.

`-d, --shift=f'
`'
     Set the interval between two consecutive frames to `f' ms. Default:
     10.0 ms.

`-w, --window=str'
`'
     Specify the waveform weighting window. Available windows are
     `Hamming', `Hanning', `Blackman' or `none'. Default: `Hamming'.

`-n, --num-filters=n'
`'
     Set the number of channels in the filter bank. Default: 24.

`-a, --alpha=f'
`'
     Set the bilinear frequency warping factor to `f'. Default: 0.

`-m, --mel'
`'
     Use MEL frequency warping. Overwrites `--alpha'.

`-i, --freq-min=f'
`'
     Set the lower frequency bound to `f' Hz. Default: 0 Hz.

`-u, --freq-max=f'
`'
     Set the upper frequency bound to `f' Hz. Default: Niquist.

`-b, --fft-length=n'
`'
     Set FFT length to `n' samples. Default: 512.

`-D, --delta'
`'
     Add first order derivatives to the feature vector.

`-A, --acceleration'
`'
     Add second order derivatives to the feature vector. Requires
     `--delta'.

`-v, --verbose'
`'
     Turn on verbose mode

`-h, --help'
`'
     Print a help message for the tool and exit.

`-V, --version'
`'
     Print version information and exit.


File: spro.info,  Node: sfbcep,  Next: slpc,  Prev: sfbank,  Up: Reference guide

5.2 `sfbcep'
============

* Menu:

* sfbcep usage::                Syntax
* sfbcep synopsis::             Brief description
* sfbcep options::              Options


File: spro.info,  Node: sfbcep usage,  Next: sfbcep synopsis,  Prev: sfbcep,  Up: sfbcep

Usage
-----

`sfbcep [options] ifile ofile'


File: spro.info,  Node: sfbcep synopsis,  Next: sfbcep options,  Prev: sfbcep usage,  Up: sfbcep

Synopsis
--------

Filter-bank based cepstral analysis of the input signal.


File: spro.info,  Node: sfbcep options,  Prev: sfbcep synopsis,  Up: sfbcep

Options
-------

`-F, --format=str'
`'
     Specify the input waveform file format. Available formats are
     `PCM16', `ALAW', `ULAW', `wave' or `sphere'. Default: `PCM16'.

`-f, --sample-rate=f'
`'
     Set input waveform sample rate to `f' Hz for `PCM16', `ALAW' or
     `ULAW' waveform files. Default: 8 kHz.

`-x, --channel=n'
`'
     Set the channel to consider for feature extraction. Default: 1.

`-B, --swap'
`'
     Swap the input waveform samples.

`-I, --input-bufsize=n'
`'
     Set the input buffer size to `n' kbytes. Default: 10 Mb.

`-O, --output-bufsize=n'
`'
     Set the output buffer size to `n' kbytes. Default: 10 Mb.

`-H, --header'
`'
     Output variable length header.

`-k, --pre-emphasis=f'
`'
     Set the pre-emphasis coefficient to `f'. Default: 0.95.

`-l --length=f'
`'
     Set the analysis frame length to `f' ms. Default: 20.0 ms.

`-d, --shift=f'
`'
     Set the interval between two consecutive frames to `f' ms. Default:
     10.0 ms.

`-w, --window=str'
`'
     Specify the waveform weighting window. Available windows are
     `Hamming', `Hanning', `Blackman' or `none'. Default: `Hamming'.

`-n, --num-filters=n'
`'
     Set the number of channels in the filter bank. Default: 24.

`-a, --alpha=f'
`'
     Set the bilinear frequency warping factor to `f'. Default: 0.

`-m, --mel'
`'
     Use MEL frequency warping. Overwrites `--alpha'.

`-i, --freq-min=f'
`'
     Set the lower frequency bound to `f' Hz. Default: 0 Hz.

`-u, --freq-max=f'
`'
     Set the upper frequency bound to `f' Hz. Default: Niquist.

`-b, --fft-length=n'
`'
     Set FFT length to `n' samples. Default: 512.

`-p, --num-ceps=n'
     Set the number of output cepstral coefficients to `n'. `n' must be
     less or equal to the number of channels in the filter bank.
     Default: 12.

`-r, --lifter=n'
     Set liftering parameter to `n'. Default: 0.

`-e, --energy'
`'
     Add log-energy to the feature vector.

`-s, --scale-energy=f'
`'
     Set scale energy factor. The way the maximum energy value is
     computed depends on whether `--segment-length' is specified or not.

`-Z, --cms'
`'
     Cepstral mean subtraction. Default: no.

`-R, --normalize'
`'
     Variance normalization (requires `--cms').  Default: no.

`-L, --segment-length=n'
`'
     Set normalization and energy scaling segment length.

`-D, --delta'
`'
     Add first order derivatives to the feature vector.

`-A, --acceleration'
`'
     Add second order derivatives to the feature vector. Requires
     `--delta'.

`-N, --no-static-energy'
`'
     Remove static log-energy from feature vector (requires `--delta').

`-v, --verbose'
`'
     Turn on verbose mode

`-h, --help'
`'
     Print a help message for the tool and exit.

`-V, --version'
`'
     Print version information and exit.


File: spro.info,  Node: slpc,  Next: slpcep,  Prev: sfbcep,  Up: Reference guide

5.3 `slpc'
==========

* Menu:

* slpc usage::                  Syntax
* slpc synopsis::               Brief description
* slpc options::                Options


File: spro.info,  Node: slpc usage,  Next: slpc synopsis,  Prev: slpc,  Up: slpc

Usage
-----

`slpc [options] ifile ofile'


File: spro.info,  Node: slpc synopsis,  Next: slpc options,  Prev: slpc usage,  Up: slpc

Synopsis
--------

Variable resolution AR modeling of the input signal.


File: spro.info,  Node: slpc options,  Prev: slpc synopsis,  Up: slpc

Options
-------

`-F, --format=str'
`'
     Specify the input waveform file format. Available formats are
     `PCM16', `ALAW', `ULAW', `wave' or `sphere'. Default: `PCM16'.

`-f, --sample-rate=f'
`'
     Set input waveform sample rate to `f' Hz for `PCM16', `ALAW' or
     `ULAW' waveform files. Default: 8 kHz.

`-x, --channel=n'
`'
     Set the channel to consider for feature extraction. Default: 1.

`-B, --swap'
`'
     Swap the input waveform samples.

`-I, --input-bufsize=n'
`'
     Set the input buffer size to `n' kbytes. Default: 10 Mb.

`-O, --output-bufsize=n'
`'
     Set the output buffer size to `n' kbytes. Default: 10 Mb.

`-H, --header'
`'
     Output variable length header.

`-k, --pre-emphasis=f'
`'
     Set the pre-emphasis coefficient to `f'. Default: 0.95.

`-l --length=f'
`'
     Set the analysis frame length to `f' ms. Default: 20.0 ms.

`-d, --shift=f'
`'
     Set the interval between two consecutive frames to `f' ms. Default:
     10.0 ms.

`-w, --window=str'
`'
     Specify the waveform weighting window. Available windows are
     `Hamming', `Hanning', `Blackman' or `none'. Default: `Hamming'.

`-n, --order=n'
`'
     Set the prediction order. Default: 12.

`-a, --alpha=f'
`'
     Set the bilinear frequency warping factor to `f'. Default: 0.

`-r, --parcor'
     Output reflection coefficients rather than linear prediction
     coefficients. Default: LPC.

`-g, --lar'
     Output log area ratios rather than linear prediction coefficients.
     Default: LPC.

`-p, --lsp'
     Output line spectrum pairs rather than linear prediction
     coefficients. Default: LPC.

`-e, --energy'
`'
     Add log-energy to the feature vector, where the energy is the LPC
     filter gain.

`-s, --scale-energy=f'
`'
     Set scale energy factor. The way the maximum energy value is
     computed depends on whether `--segment-length' is specified or not.

`-v, --verbose'
`'
     Turn on verbose mode

`-h, --help'
`'
     Print a help message for the tool and exit.

`-V, --version'
`'
     Print version information and exit.


File: spro.info,  Node: slpcep,  Next: splp,  Prev: slpc,  Up: Reference guide

5.4 `slpcep'
============

* Menu:

* slpcep usage::                Syntax
* slpcep synopsis::             Brief description
* slpcep options::              Options


File: spro.info,  Node: slpcep usage,  Next: slpcep synopsis,  Prev: slpcep,  Up: slpcep

Usage
-----

`slpcep [options] ifile ofile'


File: spro.info,  Node: slpcep synopsis,  Next: slpcep options,  Prev: slpcep usage,  Up: slpcep

Synopsis
--------

Linear prediction based cepstral analysis of the input signal.


File: spro.info,  Node: slpcep options,  Prev: slpcep synopsis,  Up: slpcep

Options
-------

`-F, --format=str'
`'
     Specify the input waveform file format. Available formats are
     `PCM16', `ALAW', `ULAW', `wave' or `sphere'. Default: `PCM16'.

`-f, --sample-rate=f'
`'
     Set input waveform sample rate to `f' Hz for `PCM16', `ALAW' or
     `ULAW' waveform files. Default: 8 kHz.

`-x, --channel=n'
`'
     Set the channel to consider for feature extraction. Default: 1.

`-B, --swap'
`'
     Swap the input waveform samples.

`-I, --input-bufsize=n'
`'
     Set the input buffer size to `n' kbytes. Default: 10 Mb.

`-O, --output-bufsize=n'
`'
     Set the output buffer size to `n' kbytes. Default: 10 Mb.

`-H, --header'
`'
     Output variable length header.

`-k, --pre-emphasis=f'
`'
     Set the pre-emphasis coefficient to `f'. Default: 0.95.

`-l --length=f'
`'
     Set the analysis frame length to `f' ms. Default: 20.0 ms.

`-d, --shift=f'
`'
     Set the interval between two consecutive frames to `f' ms. Default:
     10.0 ms.

`-w, --window=str'
`'
     Specify the waveform weighting window. Available windows are
     `Hamming', `Hanning', `Blackman' or `none'. Default: `Hamming'.

`-n, --order=n'
`'
     Set the prediction order. Default: 12.

`-a, --alpha=f'
`'
     Set the bilinear frequency warping factor to `f'. Default: 0.

`-p, --num-ceps=n'
     Set the number of output cepstral coefficients to `n'. `n' must be
     less or equal to the number of channels in the filter bank.
     Default: 12.

`-r, --lifter=n'
     Set liftering parameter to `n'. Default: 0.

`-e, --energy'
`'
     Add log-energy to the feature vector.

`-s, --scale-energy=f'
`'
     Set scale energy factor. The way the maximum energy value is
     computed depends on whether `--segment-length' is specified or not.

`-Z, --cms'
`'
     Cepstral mean subtraction. Default: no.

`-R, --normalize'
`'
     Variance normalization (requires `--cms').  Default: no.

`-L, --segment-length=n'
`'
     Set normalization and energy scaling segment length.

`-D, --delta'
`'
     Add first order derivatives to the feature vector.

`-A, --acceleration'
`'
     Add second order derivatives to the feature vector. Requires
     `--delta'.

`-N, --no-static-energy'
`'
     Remove static log-energy from feature vector (requires `--delta').

`-v, --verbose'
`'
     Turn on verbose mode

`-h, --help'
`'
     Print a help message for the tool and exit.

`-V, --version'
`'
     Print version information and exit.


File: spro.info,  Node: splp,  Next: scopy,  Prev: slpcep,  Up: Reference guide

5.5 `splp'
==========

* Menu:

* splp usage::                  Syntax
* splp synopsis::               Brief description
* splp options::                Options


File: spro.info,  Node: splp usage,  Next: splp synopsis,  Prev: splp,  Up: splp

Usage
-----

`splp [options] ifile ofile'


File: spro.info,  Node: splp synopsis,  Next: splp options,  Prev: splp usage,  Up: splp

Synopsis
--------

Perceptual linear prediction based cepstral analysis of the input
signal.


File: spro.info,  Node: splp options,  Prev: splp synopsis,  Up: splp

Options
-------

`-F, --format=str'
`'
     Specify the input waveform file format. Available formats are
     `PCM16', `ALAW', `ULAW', `wave' or `sphere'. Default: `PCM16'.

`-f, --sample-rate=f'
`'
     Set input waveform sample rate to `f' Hz for `PCM16', `ALAW' or
     `ULAW' waveform files. Default: 8 kHz.

`-x, --channel=n'
`'
     Set the channel to consider for feature extraction. Default: 1.

`-B, --swap'
`'
     Swap the input waveform samples.

`-I, --input-bufsize=n'
`'
     Set the input buffer size to `n' kbytes. Default: 10 Mb.

`-O, --output-bufsize=n'
`'
     Set the output buffer size to `n' kbytes. Default: 10 Mb.

`-H, --header'
`'
     Output variable length header.

`-k, --pre-emphasis=f'
`'
     Set the pre-emphasis coefficient to `f'. Default: 0.95.

`-l --length=f'
`'
     Set the analysis frame length to `f' ms. Default: 20.0 ms.

`-d, --shift=f'
`'
     Set the interval between two consecutive frames to `f' ms. Default:
     10.0 ms.

`-w, --window=str'
`'
     Specify the waveform weighting window. Available windows are
     `Hamming', `Hanning', `Blackman' or `none'. Default: `Hamming'.

`-n, --num-filters=n'
`'
     Set the number of channels in the filter bank. Default: 24.

`-a, --alpha=f'
`'
     Set the bilinear frequency warping factor to `f'. Default: 0.

`-m, --mel'
`'
     Use MEL frequency warping. Overwrites `--alpha'.

`-i, --freq-min=f'
`'
     Set the lower frequency bound to `f' Hz. Default: 0 Hz.

`-u, --freq-max=f'
`'
     Set the upper frequency bound to `f' Hz. Default: Niquist.

`-b, --fft-length=n'
`'
     Set FFT length to `n' samples. Default: 512.

`-c, --compress=f'
`'
     Set the power spectrum compression factor. Default: 3.

`-q, --order=n'
`'
     Set the prediction order. Default: 12.

`-a, --alpha=f'
`'
     Set the bilinear frequency warping factor to `f'. Default: 0.

`-p, --num-ceps=n'
     Set the number of output cepstral coefficients to `n'. `n' must be
     less or equal to the number of channels in the filter bank.
     Default: 12.

`-r, --lifter=n'
     Set liftering parameter to `n'. Default: 0.

`-e, --energy'
`'
     Add log-energy to the feature vector.

`-s, --scale-energy=f'
`'
     Set scale energy factor. The way the maximum energy value is
     computed depends on whether `--segment-length' is specified or not.

`-Z, --cms'
`'
     Cepstral mean subtraction. Default: no.

`-R, --normalize'
`'
     Variance normalization (requires `--cms').  Default: no.

`-L, --segment-length=n'
`'
     Set normalization and energy scaling segment length.

`-D, --delta'
`'
     Add first order derivatives to the feature vector.

`-A, --acceleration'
`'
     Add second order derivatives to the feature vector. Requires
     `--delta'.

`-N, --no-static-energy'
`'
     Remove static log-energy from feature vector (requires `--delta').

`-v, --verbose'
`'
     Turn on verbose mode

`-h, --help'
`'
     Print a help message for the tool and exit.

`-V, --version'
`'
     Print version information and exit.


File: spro.info,  Node: scopy,  Prev: splp,  Up: Reference guide

5.6 `scopy'
===========

* Menu:

* scopy usage::                 Syntax
* scopy synopsis::              Brief description
* scopy options::               Options


File: spro.info,  Node: scopy usage,  Next: scopy synopsis,  Prev: scopy,  Up: scopy

Usage
-----

`scopy [options] ifile ofile'


File: spro.info,  Node: scopy synopsis,  Next: scopy options,  Prev: scopy usage,  Up: scopy

Synopsis
--------

Copy input file to output file making necessary conversions. Possible
conversions are normalization, dynamic features, scaling, linear
transformation and component extraction.


File: spro.info,  Node: scopy options,  Prev: scopy synopsis,  Up: scopy

Options
-------

`-c, --compatibility'
`'
     Turn on compatibility and set the input file format to former SPro
     format. Default is SPro 5.0 format.

`-I, --bufsize=n'
`'
     Set the I/O buffer size in kbytes. Default is 10 Mbytes. If
     `--compatibility' is specified, the specified buffer size applies
     only to the output buffer, the entire input data being loaded into
     memory.

`-i, --info'
`'
     Print stream information.

`-z, --suppress'
`'
     Suppress data output. If this option is turned on, no output is
     created. This option is provided mainly for use with `--info' in
     order to print the stream description flag or for diagnosis
     purposes.

`-B, --swap'
`'
     Swap byte order before writing new file. Byte swapping is only
     possible if the output format is either HTK or Sirocco (see
     `--output-format' below). Default is to use the machine's natural
     byte-order.

`-o, --output-format=str'
`'
     Set the output format, where `str' is one of `ascii', `htk' or
     `sirocco'. Default is the native SPro format.

`-H, --header'
`'
     Output variable length header.

`-R, --normalize'
`'
     Variance normalization (requires `--cms').  Default: no.

`-L, --segment-length=n'
`'
     Set normalization and energy scaling segment length.

`-D, --delta'
`'
     Add first order derivatives to the feature vector.

`-A, --acceleration'
`'
     Add second order derivatives to the feature vector. Requires
     `--delta'.

`-N, --no-static-energy'
`'
     Remove static log-energy from feature vector (requires `--delta').

`-m, --scale=f'
`'
     Scale features, multiplying them by the scaling factor `f'.

`-t, --transform=str'
`'
     Apply the linear transformation whose matrix is specified in file
     `str'.

`-x, --extract=str'
`'
     Extract the specified components of the feature vector. The
     argument `str' is a comma separated list of components to extract,
     where the components are specified either as a single index or a
     range of indices specified using a dash (`-'). The index of the
     first component is 1.

`-s, --start=n'
`'
     Start copying frames at frame index `n'. Frame numbers start with
     zero. Default is 0.

`-e, --end=n'
`'
     End copying at frame index `n' (included). Frame numbers start with
     zero. Default is to copy to the end of stream.


File: spro.info,  Node: Changes,  Next: Index,  Prev: Reference guide,  Up: Top

6 Changes
*********

* Menu:

* History::                     The history of SPro
* Changes from previous version::  What's new from the previous version?
* Compatibility::               Is th current version compatible with the previous one?


File: spro.info,  Node: History,  Next: Changes from previous version,  Prev: Changes,  Up: Changes

6.1 History
===========

Here is a little bit of history before going into the details of the
changes between the two last version of SPro.

   I started the SPro project in 1996 while working at ELAN
Informatique. At the time, SPro was nothing but a simple linear
prediction analysis library for a CELP coder.

   After I left this company to go as a Ph. D. Student at ENST Paris,
the project rapidly turned into a speech processing toolkit to design
front-end processing for speech and speaker recognition algorithms. In
particular, all those nice variable resolution spectral analysis
programs were developed for my work there. I left ENST with SPro
version 3.2, a rather stable version of the toolkit but dependent upon
non GPL code and upon other toolkits I used to maintain.

   After a short pause, the project restarted when I joined IRISA as a
CNRS fellow researcher. Version 3.2 then quickly turned into version
3.3 which is the first truly GPL stand-alone distribution of SPro.
Version 3.3 also introduced the use of the `configure' script which has
made SPro developer's life easier since.

   Finally, it took quite a long time and several non fully documented
(3.3.1) or non distributed (3.3.2) intermediate versions of SPro before
the major rewrite that lead to version 4.0. Version 4.0 had basically
the same functionalities as had versions 3.x with the immense advantage
that the new version can handle signals of virtually infinite length via
the use of signal and feature streams. Implementing streamed I/O
mechanisms for waveforms and features required rewriting a lot of
functions and changing the SPro feature file format, *thus loosing both
the command and the library compatibility* (see note on the
compatibility below). I took this opportunity of a major rewrite to
undergo modifications I had been willing to do for a long time.

   Finally, in release 4.1, I added PLP analysis and a few goodies (see
changes below).

   Apart from a few features that I would like to add to SPro, the
toolkit is pretty stable and no major modifications are scehduled in
the near (or even mid-term) future.


File: spro.info,  Node: Changes from previous version,  Next: Compatibility,  Prev: History,  Up: Changes

6.2 Changes from previous version
=================================

The distribution license has been changed from GPL to a more permissive
MIT License.  Release 5.0 is in all point similar to 4.1 except for the
license change.


File: spro.info,  Node: Compatibility,  Prev: Changes from previous version,  Up: Changes

6.3 Compatibility
=================

Release 5.0 is fully compatible with 4.* releases.

   In case you did not get it, *from version 4.0, the compatibility is
lost with previous releases*. As mentioned previously, the main reason
for a new organization of SPro starting with version 4.0 is the ability
to process arbitrary length streams.

   To enable arbitrary length streams, the feature file format has
changed and feature files (formerly known as data files) generated with
a version of SPro prior to 4.0 can not be used directly in 4.0 and above
versions. However, the `scopy' tool provides a compatibility option
which enables the import of feature files from previous SPro releases.

   The lack of compatibility also extends to the library. Programs
based on former releases of the library will not compile anymore.


File: spro.info,  Node: Index,  Prev: Changes,  Up: Top

Index
*****

 [index ]
* Menu:

* *:                                     Filter-bank.         (line  54)
* acceleration, adding features:         Operations on feature streams.
                                                              (line   6)
* BLACKMAN window:                       Short term analysis. (line   6)
* bugs, reporting:                       Bugs.                (line   6)
* cepstral mean subtraction:             Deltas and normalization.
                                                              (line   6)
* cepstrum:                              Cepstrum.            (line   6)
* contributors:                          Contributors.        (line   6)
* dct:                                   Cosine transform.    (line  18)
* dct_init:                              Cosine transform.    (line  12)
* dct_reset:                             Cosine transform.    (line  24)
* delta:                                 Deltas and normalization.
                                                              (line   6)
* delta, adding features:                Operations on feature streams.
                                                              (line   6)
* derivatives:                           Deltas and normalization.
                                                              (line   6)
* extracting components:                 Operations on feature streams.
                                                              (line   6)
* fft:                                   Fourier transform.   (line  23)
* fft_init:                              Fourier transform.   (line  17)
* fft_reset:                             Fourier transform.   (line  33)
* file format, feature streams:          Feature file format. (line   6)
* file format, waveform streams:         Waveform file format.
                                                              (line   6)
* file formats:                          File formats.        (line   6)
* filter-bank, analysis:                 Filter-banks.        (line   6)
* filter-bank, tools:                    Filter-bank analysis tools.
                                                              (line   6)
* filter_bank:                           Filter-bank.         (line  37)
* format, feature streams:               Feature file format. (line   6)
* format, waveform streams:              Waveform file format.
                                                              (line   6)
* get_flag_bits:                         Feature description flags.
                                                              (line  39)
* get_next_sig_frame:                    Reading frames.      (line  16)
* get_next_spf_vec:                      Reading and writing feature vectors.
                                                              (line  28)
* get_spf_buf_vec:                       Accessing buffer elements.
                                                              (line  13)
* HAMMING window:                        Short term analysis. (line   6)
* HANNING window:                        Short term analysis. (line   6)
* header format:                         Feature file format. (line   6)
* I/O, stdin and stdout:                 I/O via stdin and stdout.
                                                              (line   6)
* input, stdin:                          I/O via stdin and stdout.
                                                              (line   6)
* installation:                          Installing.          (line   6)
* license:                               License.             (line   6)
* line spectrum pairs:                   LPC analysis.        (line   6)
* linear prediction coefficients:        LPC analysis.        (line   6)
* linear prediction, tools:              LPC analysis tools.  (line   6)
* linear transformation:                 Operations on feature streams.
                                                              (line   6)
* log area ratio:                        LPC analysis.        (line   6)
* log_filter_bank:                       Filter-bank.         (line  47)
* lpc:                                   Linear prediction.   (line  20)
* lpc_to_cep:                            LPC conversion.      (line  18)
* lpc_to_lsf:                            LPC conversion.      (line  12)
* MEL frequency scale:                   Filter-banks.        (line   6)
* MIT License:                           License.             (line   6)
* normalization, mean removal:           Deltas and normalization.
                                                              (line   6)
* normalization, variance:               Deltas and normalization.
                                                              (line   6)
* option, feature vector content:        Feature vector options.
                                                              (line   6)
* options, common:                       Common options.      (line   6)
* options, I/O:                          I/O options.         (line   6)
* options, miscellaneous:                Miscellaneous options.
                                                              (line   6)
* options, waveform framing:             Framing options.     (line   6)
* output, stdout:                        I/O via stdin and stdout.
                                                              (line   6)
* Perceptual Linear Prediction:          PLP analysis.        (line   6)
* pipes, using pipes with SPro:          I/O via stdin and stdout.
                                                              (line   6)
* PLP:                                   PLP analysis.        (line   6)
* pre-emphasis:                          Short term analysis. (line   6)
* refc_to_lar:                           LPC conversion.      (line  23)
* reflection coefficients:               LPC analysis.        (line   6)
* scale_energy:                          Feature conversion.  (line 107)
* scopy:                                 Manipulating features.
                                                              (line   6)
* set_alpha_idx:                         Filter-bank.         (line  27)
* set_flag_bits:                         Feature description flags.
                                                              (line  30)
* set_lifter:                            Miscellaneous functions.
                                                              (line  53)
* set_mel_idx:                           Filter-bank.         (line  17)
* set_sig_win:                           Reading frames.      (line  25)
* set_stream_energy_scale:               Conversion flags.    (line  34)
* set_stream_seg_length:                 Conversion flags.    (line  40)
* sfbank:                                Filter-bank magnitudes.
                                                              (line   6)
* sfbcep:                                Filter-bank cepstrum.
                                                              (line   6)
* sig_alloc:                             Waveform memory allocation.
                                                              (line  15)
* sig_correl:                            Linear prediction.   (line  13)
* sig_free:                              Waveform memory allocation.
                                                              (line  19)
* sig_normalize:                         Computing frame energy.
                                                              (line  10)
* sig_stream_close:                      Opening waveform streams.
                                                              (line  31)
* sig_stream_open:                       Opening waveform streams.
                                                              (line  16)
* sig_weight:                            Reading frames.      (line  33)
* slpc:                                  Linear prediction coefficients.
                                                              (line   6)
* slpcep:                                Linear prediction cepstrum.
                                                              (line   6)
* sp_flag_to_str:                        Feature description flags.
                                                              (line  59)
* sp_str_to_flag:                        Feature description flags.
                                                              (line  53)
* spf_buf_alloc:                         Buffer allocation.   (line  10)
* spf_buf_append:                        Accessing buffer elements.
                                                              (line  19)
* spf_buf_convert:                       Feature conversion.  (line  64)
* spf_buf_free:                          Buffer allocation.   (line  34)
* spf_buf_normalize:                     Feature conversion.  (line  85)
* spf_buf_read:                          Buffer I/O.          (line  19)
* spf_buf_resize:                        Buffer allocation.   (line  18)
* spf_buf_write:                         Buffer I/O.          (line  26)
* spf_delta_set:                         Feature conversion.  (line  96)
* spf_header_add:                        Accessing stream attributes.
                                                              (line  47)
* spf_header_get:                        Accessing stream attributes.
                                                              (line  37)
* spf_indexes:                           Miscellaneous functions.
                                                              (line  21)
* spf_input_stream_open:                 Opening for I/O.     (line  19)
* spf_output_stream_open:                Opening for I/O.     (line  27)
* spf_stream_buf:                        Buffers and streams. (line  12)
* spf_stream_dim:                        Accessing stream attributes.
                                                              (line  18)
* spf_stream_flag:                       Accessing stream attributes.
                                                              (line  26)
* spf_stream_flush:                      Reading and writing feature vectors.
                                                              (line  39)
* spf_stream_header:                     Accessing stream attributes.
                                                              (line  32)
* spf_stream_name:                       Accessing stream attributes.
                                                              (line  10)
* spf_stream_rate:                       Accessing stream attributes.
                                                              (line  15)
* spf_stream_read:                       Reading and writing feature vectors.
                                                              (line  24)
* spf_stream_rewind:                     Seeking into a stream.
                                                              (line  37)
* spf_stream_seek:                       Seeking into a stream.
                                                              (line  20)
* spf_stream_tell:                       Seeking into a stream.
                                                              (line  34)
* spf_stream_write:                      Reading and writing feature vectors.
                                                              (line  34)
* spf_tot_dim:                           Miscellaneous functions.
                                                              (line  48)
* splp:                                  PLP cepstrum.        (line   6)
* variable length header format:         Feature file format. (line   6)
* waveform, file format:                 Waveform file format.
                                                              (line   6)
* window, weighting:                     Short term analysis. (line   6)



Tag Table:
Node: Top240
Node: Introduction799
Node: Overview1245
Node: Content2990
Node: Installing4219
Node: License5903
Node: Bugs7322
Node: Contributors7649
Node: Speech analysis8064
Node: Short term analysis8917
Node: Variable resolution10237
Ref: Variable resolution-Footnote-112213
Node: Filter-banks12461
Ref: Filter-banks-Footnote-113960
Node: LPC analysis14001
Node: PLP analysis16288
Node: Cepstrum16939
Ref: Cepstrum-Footnote-118740
Node: Deltas and normalization18884
Node: SPro tools20278
Node: File formats20753
Node: Waveform file format21195
Ref: Waveform file format-Footnote-122877
Ref: Waveform file format-Footnote-222999
Node: Feature file format23129
Ref: Feature file format-Footnote-126650
Node: Common options26788
Node: I/O options27401
Ref: I/O options-Footnote-129623
Node: Framing options29929
Node: Feature vector options30693
Node: Miscellaneous options32075
Node: I/O via stdin and stdout32491
Node: Extracting features33367
Node: Filter-bank analysis tools33701
Node: Filter-bank magnitudes34162
Node: Filter-bank cepstrum35519
Node: Filter-bank options36931
Node: LPC analysis tools38961
Node: Linear prediction coefficients39457
Node: Linear prediction cepstrum40625
Node: PLP cepstrum41918
Node: LPC Options42600
Node: Manipulating features44361
Node: Operations on feature streams45309
Ref: Operations on feature streams-Footnote-149553
Node: Exporting features49611
Ref: Exporting features-Footnote-152201
Ref: Exporting features-Footnote-252309
Ref: Exporting features-Footnote-352428
Node: Importing from a previous SPro release52544
Node: Copy options53321
Node: SPro library55360
Ref: SPro library-Footnote-156974
Node: Waveform streams57039
Node: Waveform memory allocation57743
Node: Opening waveform streams58680
Node: Reading frames60461
Ref: Reading frames-Footnote-163091
Node: Computing frame energy63180
Node: Feature description flags63656
Node: Feature streams66824
Node: Opening feature streams67626
Node: Conversion flags68273
Node: Opening for I/O70833
Node: Accessing stream attributes72966
Node: Reading and writing feature vectors75855
Node: Seeking into a stream78034
Node: Storing features without streams80100
Node: Buffer allocation82057
Node: Accessing buffer elements83911
Node: Buffer I/O86442
Node: Buffers and streams87743
Node: Feature conversion88754
Ref: Feature conversion-Footnote-194962
Node: FFT-based functions95150
Node: Fourier transform95600
Node: Filter-bank97436
Node: Cosine transform100555
Node: LPC-based functions101695
Node: Linear prediction102263
Node: LPC conversion103445
Node: Miscellaneous functions104521
Node: Reference guide107318
Node: sfbank107968
Node: sfbank usage108229
Node: sfbank synopsis108366
Node: sfbank options108528
Node: sfbcep110589
Node: sfbcep usage110839
Node: sfbcep synopsis110976
Node: sfbcep options111153
Node: slpc114017
Node: slpc usage114263
Node: slpc synopsis114390
Node: slpc options114555
Node: slpcep116687
Node: slpcep usage116935
Node: slpcep synopsis117072
Node: slpcep options117255
Node: splp119776
Node: splp usage120021
Node: splp synopsis120148
Node: splp options120334
Node: scopy123426
Node: scopy usage123658
Node: scopy synopsis123790
Node: scopy options124082
Node: Changes126520
Node: History126847
Node: Changes from previous version129069
Node: Compatibility129408
Node: Index130328

End Tag Table
